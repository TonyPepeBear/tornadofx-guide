
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>11. Editing Models and Validation · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="12. TornadoFX IDEA Plugin.html" />
    
    
    <link rel="prev" href="10. FXML.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="0. Subsection.html">
            
                <a href="0. Subsection.html">
            
                    
                    第一部分: TornadoFX 基本介紹
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="1. Why TornadoFX.html">
            
                <a href="1. Why TornadoFX.html">
            
                    
                    1. 為什麼選擇 TornadoFX?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="2. Setting Up.html">
            
                <a href="2. Setting Up.html">
            
                    
                    2. 配置
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="3. Components.html">
            
                <a href="3. Components.html">
            
                    
                    3. 組件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="4. Basic Controls.html">
            
                <a href="4. Basic Controls.html">
            
                    
                    4. Basic Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="5. Data Controls.html">
            
                <a href="5. Data Controls.html">
            
                    
                    5. Data Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="6. CSS.html">
            
                <a href="6. CSS.html">
            
                    
                    6. Type Safe CSS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="7. Layouts and Menus.html">
            
                <a href="7. Layouts and Menus.html">
            
                    
                    7. Layouts and Menus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="8. Charts.html">
            
                <a href="8. Charts.html">
            
                    
                    8. Charts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="9. Shapes and Animation.html">
            
                <a href="9. Shapes and Animation.html">
            
                    
                    9. Shapes and Animation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="10. FXML.html">
            
                <a href="10. FXML.html">
            
                    
                    10. FXML
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.11" data-path="11. Editing Models and Validation.html">
            
                <a href="11. Editing Models and Validation.html">
            
                    
                    11. Editing Models and Validation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="12. TornadoFX IDEA Plugin.html">
            
                <a href="12. TornadoFX IDEA Plugin.html">
            
                    
                    12. TornadoFX IDEA Plugin
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../part2/0. Subsection.html">
            
                <a href="../part2/0. Subsection.html">
            
                    
                    Part 2: TornadoFX Advanced Features
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../part2/Property Delegates.html">
            
                <a href="../part2/Property Delegates.html">
            
                    
                    Property Delegates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../part2/Advanced Data Controls.html">
            
                <a href="../part2/Advanced Data Controls.html">
            
                    
                    Advanced Data Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../part2/OSGi.html">
            
                <a href="../part2/OSGi.html">
            
                    
                    OSGi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../part2/Scopes.html">
            
                <a href="../part2/Scopes.html">
            
                    
                    Scopes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../part2/EventBus.html">
            
                <a href="../part2/EventBus.html">
            
                    
                    EventBus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../part2/Workspaces.html">
            
                <a href="../part2/Workspaces.html">
            
                    
                    Workspaces
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../part2/Layout Debugger.html">
            
                <a href="../part2/Layout Debugger.html">
            
                    
                    Layout Debugger
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../part2/Internationalization.html">
            
                <a href="../part2/Internationalization.html">
            
                    
                    Internationalization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../part2/Config Settings and State.html">
            
                <a href="../part2/Config Settings and State.html">
            
                    
                    Config Settings and State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../part2/JSON and REST.html">
            
                <a href="../part2/JSON and REST.html">
            
                    
                    JSON and REST
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="../part2/Dependency Injection.html">
            
                <a href="../part2/Dependency Injection.html">
            
                    
                    Dependency Injection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="../part2/Wizard.html">
            
                <a href="../part2/Wizard.html">
            
                    
                    Wizard
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="../part2/Integration.html">
            
                <a href="../part2/Integration.html">
            
                    
                    Integrating with other tech
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../part3/0. Subsection.html">
            
                <a href="../part3/0. Subsection.html">
            
                    
                    Part 3: Cook Book
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../part3/Snippets.html">
            
                <a href="../part3/Snippets.html">
            
                    
                    Snippets
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >11. Editing Models and Validation</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="editing-models-and-validation">Editing Models and Validation</h1>
<p>TornadoFX doesn&apos;t force any particular architectural pattern on you as a developer, and it works equally well with both <a href="https://en.wikipedia.org/wiki/Model&#x2013;view&#x2013;controller" target="_blank">MVC</a>, <a href="https://en.wikipedia.org/wiki/Model&#x2013;view&#x2013;presenter" target="_blank">MVP</a>, and their derivatives.</p>
<p>To help with implementing these patterns TornadoFX provides a tool called <code>ViewModel</code> that helps cleanly separate your UI and business logic, giving you features like <em>rollback</em>/<em>commit</em> and <em>dirty state checking</em>. These patterns are hard or cumbersome to implement manually, so it is advised to leverage the <code>ViewModel</code> and <code>ItemViewModel</code> when it is needed.</p>
<p>Typically you will use the <code>ItemViewModel</code> when you are creating a facade in front of a single object, and a  <code>ViewModel</code>for more complex situations.</p>
<h2 id="a-typical-use-case">A Typical Use Case</h2>
<p>Say you have a given domain type <code>Person</code>. We allow its two properties to be nullable so they can be inputted later by the user.</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">import</span> tornadofx.*

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(name: String? = <span class="hljs-literal">null</span>, title: String? = <span class="hljs-literal">null</span>) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> nameProperty</span> = SimpleStringProperty(this, <span class="hljs-string">&quot;name&quot;</span>, name)
    <span class="hljs-variable"><span class="hljs-keyword">var</span> name by nameProperty

    <span class="hljs-keyword">val</span> titleProperty</span> = SimpleStringProperty(this, <span class="hljs-string">&quot;title&quot;</span>, title)
    <span class="hljs-variable"><span class="hljs-keyword">var</span> title by titleProperty 
}
</span></code></pre>
<p>(Notice the import, you need to import at least <code>tornadofx.getValue</code> and <code>tornadofx.setValue</code> for the <em>by</em> delegate to work)</p>
<p>Consider a Master/Detail view where you have a <code>TableView</code> displaying a list of people, and a <code>Form</code> where the currently selected person&apos;s information can be edited. Before we get into the <code>ViewModel</code>, we will create a version of this <code>View</code> without using the <code>ViewModel</code>.</p>
<p><img src="https://i.imgur.com/KDWkFBy.png" alt=""></p>
<p><strong>Figure 11.1</strong></p>
<p>Below is code for our first attempt in building this, and it has a number of problems we will address.</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">import</span> javafx.scene.control.TableView
<span class="hljs-keyword">import</span> javafx.scene.control.TextField
<span class="hljs-keyword">import</span> javafx.scene.layout.BorderPane
<span class="hljs-keyword">import</span> tornadofx.*

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(name: String? = <span class="hljs-literal">null</span>, title: String? = <span class="hljs-literal">null</span>) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> nameProperty</span> = SimpleStringProperty(this, <span class="hljs-string">&quot;name&quot;</span>, name)
    <span class="hljs-variable"><span class="hljs-keyword">var</span> name by nameProperty

    <span class="hljs-keyword">val</span> titleProperty</span> = SimpleStringProperty(this, <span class="hljs-string">&quot;title&quot;</span>, title)
    <span class="hljs-variable"><span class="hljs-keyword">var</span> title by titleProperty 
}

class PersonEditor</span> : View(<span class="hljs-string">&quot;Person Editor&quot;</span>) {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = BorderPane()
    <span class="hljs-variable"><span class="hljs-keyword">var</span> nameField</span> : TextField by singleAssign()
    <span class="hljs-variable"><span class="hljs-keyword">var</span> titleField</span> : TextField by singleAssign()
    <span class="hljs-variable"><span class="hljs-keyword">var</span> personTable</span> : TableView<span class="hljs-type">&lt;Person&gt;</span> by singleAssign()
    <span class="hljs-comment">// Some fake data for our table</span>
    <span class="hljs-variable"><span class="hljs-keyword">val</span> persons</span> = listOf(Person(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Manager&quot;</span>), Person(<span class="hljs-string">&quot;Jay&quot;</span>, <span class="hljs-string">&quot;Worker bee&quot;</span>)).observable()

    <span class="hljs-variable"><span class="hljs-keyword">var</span> prevSelection</span>: Person? = <span class="hljs-literal">null</span>

    init {
        with(root) {
            <span class="hljs-comment">// TableView showing a list of people</span>
            center {
                tableview(persons) {
                    personTable = this
                    column(<span class="hljs-string">&quot;Name&quot;</span>, Person::nameProperty)
                    column(<span class="hljs-string">&quot;Title&quot;</span>, Person::titleProperty)

                    <span class="hljs-comment">// Edit the currently selected person</span>
                    selectionModel.selectedItemProperty().onChange {
                        editPerson(it)
                        prevSelection = it
                    }
                }
            }

            right {
                form {
                    fieldset(<span class="hljs-string">&quot;Edit person&quot;</span>) {
                        field(<span class="hljs-string">&quot;Name&quot;</span>) {
                            textfield() {
                                nameField = this
                            }
                        }
                        field(<span class="hljs-string">&quot;Title&quot;</span>) {
                            textfield() {
                                titleField = this
                            }
                        }
                        button(<span class="hljs-string">&quot;Save&quot;</span>).action {
                            save()
                        }
                    }
                }
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">editPerson</span><span class="hljs-params">(person: <span class="hljs-type">Person?</span>)</span> {</span>
        <span class="hljs-keyword">if</span> (person != <span class="hljs-literal">null</span>) {
            prevSelection?.apply {
                nameProperty.unbindBidirectional(nameField.textProperty())
                titleProperty.unbindBidirectional(titleField.textProperty())
            }
            nameField.bind(person.nameProperty)
            titleField.bind(person.titleProperty)
            prevSelection = person
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-comment">// Extract the selected person from the tableView</span>
        <span class="hljs-variable"><span class="hljs-keyword">val</span> person</span> = personTable.selectedItem!!

        <span class="hljs-comment">// A real application would persist the person here</span>
        println(<span class="hljs-string">&quot;Saving ${person.name} / ${person.title}&quot;</span>)
    }
}
</code></pre>
<p>We define a <code>View</code> consisting of a <code>TableView</code> in the center of a <code>BorderPane</code> and a <code>Form</code> on the right side. We define some properties for the form fields and the table itself so we can reference them later.</p>
<p>While we build the table, we attach a listener to the selected item so we can call the <code>editPerson</code> function when the table selection changes. The <code>editPerson</code> function binds the properties of the selected person to the text fields in the form.</p>
<h2 id="problems-with-our-initial-attempt">Problems with our initial attempt</h2>
<p>At first glance it might look OK, but when we dig deeper there are several issues.</p>
<h3 id="manual-binding">Manual binding</h3>
<p>Every time the selection in the table changes, we have to unbind/rebind the data for the form fields manually. Apart from the added code and logic, there is another huge problem with this: the data is updated for every change in the text fields, and the changes will even be reflected in the table. While this might look cool and is technically correct, it presents one big problem: what if the user does not want to save the changes? We have no way of rolling back. So to prevent this, we would have to skip the binding altogether and manually extract the values from the text fields, then create a new <code>Person</code> object on save. In fact, this is a pattern found in many applications and expected by most users. Implementing a &quot;Reset&quot; button for this form would mean managing variables with the initial values and again assigning those values manually to the text fields.</p>
<h3 id="tight-coupling">Tight Coupling</h3>
<p>Another issue is when it is time to save the edited person, the save function has to extract the selected item from the table again. For that to happen the save function has to know about the <code>TableView</code>. Alternatively it would have to know about the text fields like the <code>editPerson</code> function does, and manually extract the values to reconstruct a <code>Person</code> object.</p>
<h2 id="introducing-viewmodel">Introducing ViewModel</h2>
<p>The <code>ViewModel</code> is a mediator between the <code>TableView</code> and the <code>Form</code>. It acts as a middleman between the data in the text fields and the data in the actual <code>Person</code> object. As you will see, the code is much shorter and easier to reason about. The implementation code of the <code>PersonModel</code> will be shown shortly. For now just focus on its usage. Please note that this is not the recommended syntax, this merely serves as an explanation of the concepts.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonEditor</span> : <span class="hljs-type">View</span></span>(<span class="hljs-string">&quot;Person Editor&quot;</span>) {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = BorderPane()
    <span class="hljs-variable"><span class="hljs-keyword">val</span> persons</span> = listOf(Person(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Manager&quot;</span>), Person(<span class="hljs-string">&quot;Jay&quot;</span>, <span class="hljs-string">&quot;Worker bee&quot;</span>)).observable()
    <span class="hljs-variable"><span class="hljs-keyword">val</span> model</span> = PersonModel(Person())

    init {
        with(root) {
            center {
                tableview(persons) {
                    column(<span class="hljs-string">&quot;Name&quot;</span>, Person::nameProperty)
                    column(<span class="hljs-string">&quot;Title&quot;</span>, Person::titleProperty)

                    <span class="hljs-comment">// Update the person inside the view model on selection change</span>
                    model.rebindOnChange(this) { selectedPerson -&gt;
                        item = selectedPerson ?: Person()
                    }
                }
            }

            right {
                form {
                    fieldset(<span class="hljs-string">&quot;Edit person&quot;</span>) {
                        field(<span class="hljs-string">&quot;Name&quot;</span>) {
                            textfield(model.name)
                        }
                        field(<span class="hljs-string">&quot;Title&quot;</span>) {
                            textfield(model.title)
                        }
                        button(<span class="hljs-string">&quot;Save&quot;</span>) {
                            enableWhen(model.dirty)
                            action {
                                save()
                            }
                        }
                        button(<span class="hljs-string">&quot;Reset&quot;</span>).action {
                            model.rollback()
                        }
                    }
                }
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-comment">// Flush changes from the text fields into the model</span>
        model.commit()

        <span class="hljs-comment">// The edited person is contained in the model</span>
        <span class="hljs-variable"><span class="hljs-keyword">val</span> person</span> = model.item

        <span class="hljs-comment">// A real application would persist the person here</span>
        println(<span class="hljs-string">&quot;Saving ${person.name} / ${person.title}&quot;</span>)
    }

}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonModel</span></span>(person: Person) : ItemViewModel<span class="hljs-type">&lt;Person&gt;</span>(person) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> name</span> = bind(Person::nameProperty)
    <span class="hljs-variable"><span class="hljs-keyword">val</span> title</span> = bind(Person::titleProperty)
}
</code></pre>
<p>This looks a lot better, but what exactly is going on here? We have introduced a subclass of <code>ViewModel</code> called <code>PersonModel</code>. The model holds a <code>Person</code> object and has properties for the <code>name</code> and <code>title</code> fields. We will discuss the model further after we have looked at the rest of the client code.</p>
<p>Note that we hold no reference to the <code>TableView</code> or the text fields. Apart from a lot less code, the first big change is the way we update the <code>Person</code> inside the model:</p>
<pre><code class="lang-kotlin">model.rebindOnChange(this) { selectedPerson -&gt;
    person = selectedPerson ?: Person()
}
</code></pre>
<p>The <code>rebindOnChange()</code> function takes the <code>TableView</code> as an argument and a function that will be called when the selection changes. This works with <code>ListView</code>,<code>TreeView</code>, <code>TreeTableView</code>, and any other <code>ObservableValue</code> as well. This function is called on the model and has the <code>selectedPerson</code> as its single argument. We assign the selected person to the <code>person</code> property of the model, or a new  <code>Person</code> if the selection was empty/null. That way we ensure that there is always data for the model to present.</p>
<p>When we create the TextFields, we bind the model properties directly to it since most <code>Node</code> builders accept an <code>ObservableValue</code> to bind to.</p>
<pre><code class="lang-kotlin">field(<span class="hljs-string">&quot;Name&quot;</span>) {
    textfield(model.name)
}
</code></pre>
<p>Even when the selection changes, the model properties persist but the values for the properties are updated. We totally avoid the manual binding from our previous attempt.</p>
<p>Another big change in this version is that the data in the table does not update when we type into the text fields. This is because the model has exposed a copy of the properties from the person object and does not write back into the actual person object before we call <code>model.commit()</code>. This is exactly what we do in the <code>save</code> function. Once <code>commit</code> has been called, the data in the facade is flushed back into our person object and the table will now reflect our changes.</p>
<h2 id="rollback">Rollback</h2>
<p>Since the model holds a reference to the actual <code>Person</code> object, we can reset the text fields to reflect the actual data in our <code>Person</code> object. We could add a reset button like this:</p>
<pre><code class="lang-kotlin">button(<span class="hljs-string">&quot;Reset&quot;</span>).action {
    model.rollback()
}
</code></pre>
<p>When the button is pressed, any changes are discarded and the text fields show the actual <code>Person</code> object values again.</p>
<h2 id="the-personmodel">The PersonModel</h2>
<p>We never explained how the <code>PersonModel</code> works yet, and you probably have been wondering about how the <code>PersonModel</code> is implemented. Here it is:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonModel</span></span>(person: Person) : ItemViewModel<span class="hljs-type">&lt;Person&gt;</span>(person) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> name</span> = bind(Person::nameProperty)
    <span class="hljs-variable"><span class="hljs-keyword">val</span> title</span> = bind(Person::titleProperty)
}
</code></pre>
<p>It can hold a <code>Person</code> object, and it has defined two strange-looking properties called <code>name</code> and <code>title</code> via the <code>bind</code> delegate. Yeah it looks weird, but there is a very good reason for it. The <code>{ person.nameProperty }</code> parameter for the <code>bind</code> function is a lambda that returns a property. This returned property is examined by the <code>ViewModel</code>, and a new property of the same type is created. It is then put into the <code>name</code> property of the <code>ViewModel</code>.</p>
<p>When we bind a text field to the <code>name</code> property of the model, only the copy is updated when you type into the text field. The <code>ViewModel</code> keeps track of which actual property belongs to which facade, and when you call <code>commit</code> the values from the facade are flushed into the actual backing property. On the flip side, when you call <code>rollback</code> the exact opposite happens: The actual property value is flushed into the facade.</p>
<p>The reason the actual property is wrapped in a function is that this makes it possible to change the <code>person</code> variable and then extract the property from that new person. You can read more about this below (rebinding).</p>
<h2 id="dirty-checking">Dirty Checking</h2>
<p>The model has a <code>Property</code> called <code>dirty</code>. This is a <code>BooleanBinding</code>  which you can observe to enable or disable certain features. For example, we could easily disable the save button until there are actual changes. The updated save button would look like this:</p>
<pre><code class="lang-kotlin">button(<span class="hljs-string">&quot;Save&quot;</span>) {
    enableWhen(model.dirty)
    action {
        save()
    }
}
</code></pre>
<p>There is also a plain <code>val</code> called <code>isDirty</code> which returns a <code>Boolean</code> representing the dirty state for the entire model.</p>
<p>One thing to note is that if the backing object is being modified while the <code>ViewModel</code> is also modified via the UI, all uncommitted changes in the <code>ViewModel</code> are being overridden by the changes in the backing object. That means the data in the <code>ViewModel</code> might get lost if external modification of the backing object takes place.</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> person</span> = Person(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Manager&quot;</span>)
<span class="hljs-variable"><span class="hljs-keyword">val</span> model</span> = PersonModel(person)

model.name.value = <span class="hljs-string">&quot;Johnny&quot;</span>   <span class="hljs-comment">//modify the ViewModel</span>
person.name = <span class="hljs-string">&quot;Johan&quot;</span>         <span class="hljs-comment">//modify the underlying object</span>

println(<span class="hljs-string">&quot;  Person = ${person.name}, ${person.title}&quot;</span>)             <span class="hljs-comment">//output:   Person = Johan, Manager</span>
println(<span class="hljs-string">&quot;Is dirty = ${model.isDirty}&quot;</span>)                            <span class="hljs-comment">//output: Is dirty = false</span>
println(<span class="hljs-string">&quot;   Model = ${model.name.value}, ${model.title.value}&quot;</span>)   <span class="hljs-comment">//output:    Model = Johan, Manager</span>
</code></pre>
<p>As can be seen above the changes in the <code>ViewModel</code> got overridden when the underlying object was modified. And the <code>ViewModel</code> was not flagged as <code>dirty</code>.</p>
<h2 id="dirty-properties">Dirty Properties</h2>
<p>You can check if a specific property is dirty, meaning that it has been changed compared to the backing source object value.</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> nameWasChanged</span> = model.isDirty(model.name)
</code></pre>
<p>There is also an extension property version that accomplishes the same task:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> nameWasChanged</span> = model.name.isDirty
</code></pre>
<p>The shorthand version is an extension <code>val</code> on <code>Property&lt;T&gt;</code> but it will only work for properties that are bound inside a <code>ViewModel</code>. You will find <code>model.isNotDirty</code> properties as well.</p>
<p>If you need to dynamically react based on the dirty state of a specific property in the <code>ViewModel</code>, you can get a hold of a <code>BooleanBinding</code> representing the dirty state of that field like this:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> nameDirtyProperty</span> = model.dirtyStateFor(PersonModel::name)
</code></pre>
<h2 id="extracting-the-source-object-value">Extracting the Source Object Value</h2>
<p>To retrieve the backing object value for a property you can call <code>model.backingValue(property)</code>.</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> person</span> = model.backingValue(property)
</code></pre>
<h2 id="specific-property-subtypes-integerproperty-booleanproperty">Specific Property Subtypes (IntegerProperty, BooleanProperty)</h2>
<p>If you bind, for example, an <code>IntegerProperty</code>, the type of the facade property will look like <code>Property&lt;Int&gt;</code> but it is infact an <code>IntegerProperty</code> under the hood. If you need to access the special functions provided by <code>IntegerProperty</code>, you will have to cast the bind result:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> age</span> = bind(Person::ageProperty) <span class="hljs-keyword">as</span> IntegerProperty
</code></pre>
<p>Similarily, you can expose a read only property by specifying a read only type:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> age</span> = bind(Person::ageProperty) <span class="hljs-keyword">as</span> ReadOnlyIntegerProperty
</code></pre>
<p>The reason for this is an unfortunate shortcoming on the type system that prevents the compiler from differentiating between overloaded <code>bind</code> functions for these specific types, so the single <code>bind</code> function inside <code>ViewModel</code> inspects the property type and returns the best match, but unfortunately the return type signature has to be <code>Property&lt;T&gt;</code> for now.</p>
<h2 id="rebinding">Rebinding</h2>
<p>As you saw in the <code>TableView</code> example above, it is possible to change the domain object that is wrapped by the <code>ViewModel</code>. This test case sheds some more light on that:</p>
<pre><code class="lang-kotlin">@Test <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swap_source_object</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-variable"><span class="hljs-keyword">val</span> person1</span> = Person(<span class="hljs-string">&quot;Person 1&quot;</span>)
    <span class="hljs-variable"><span class="hljs-keyword">val</span> person2</span> = Person(<span class="hljs-string">&quot;Person 2&quot;</span>)

    <span class="hljs-variable"><span class="hljs-keyword">val</span> model</span> = PersonModel(person1)
    assertEquals(model.name, <span class="hljs-string">&quot;Person 1&quot;</span>)

    model.rebind { person = person2 }
    assertEquals(model.name, <span class="hljs-string">&quot;Person 2&quot;</span>)
}
</code></pre>
<p>The test creates two <code>Person</code> objects and a <code>ViewModel</code>. The model is initialised with the first person object. It then checks that <code>model.name</code> corresponds to the name in <code>person1</code>. Now something weird happens:</p>
<pre><code class="lang-kotlin">model.rebind { person = person2 }
</code></pre>
<p>The code inside the <code>rebind()</code> block above will be executed and all the properties of the model are updated with values from the new source object. This is actually analogous to writing:</p>
<pre><code class="lang-kotlin">model.person = person2
model.rebind()
</code></pre>
<p>The form you choose is up to you, but the first form makes sure you do not forget to call rebind. After <code>rebind</code> is called, the model is not dirty and all values will reflect the ones form the new source object or source objects. It&apos;s important to note that you can pass multiple source objects to a view model and update all or some of them as you see fit.</p>
<h3 id="rebind-listener">Rebind Listener</h3>
<p>Our <code>TableView</code> example called the <code>rebindOnChange()</code> function and passed in a <code>TableView</code> as the first argument. This made sure that rebind was called whenever the selection of the <code>TableView</code> changed. This is actually just a shortcut to another function with the same name that takes an observable and calls rebind whenever that observable changes. If you call this function, you do not need to call rebind manually as long as you have an observable that represent the state change that should cause the model to rebind.</p>
<p>As you saw, <code>TableView</code> has a shorthand support for the <code>selectionModel.selectedItemProperty</code>. If not for this shorthand function call, you would have to write it like this:</p>
<pre><code class="lang-kotlin">model.rebindOnChange(table.selectionModel.selectedItemProperty()) {
    item = it ?: Person()
}
</code></pre>
<p>The above example is included to clarify how the <code>rebindOnChange()</code> function works under the hood. For real use cases involving a <code>TableView</code>, you should opt for the <code>bindSelected(model)</code> function that is available when you combine <code>TableView</code> and <code>ItemViewModel</code>.</p>
<h2 id="itemviewmodel">ItemViewModel</h2>
<p>When working with the <code>ViewModel</code> you will notice some repetitive and somewhat verbose tasks. They include calling <code>rebind</code> or configuring <code>rebindOnChange</code> to change the source object. The <code>ItemViewModel</code> is an extension to the <code>ViewModel</code> and in almost all use cases you would want to inherit from this instead of the <code>ViewModel</code> class.</p>
<p>The <code>ItemViewModel</code> has a property called <code>itemProperty</code> of the specified type, so our <code>PersonModel</code> would now look like:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonModel</span> : <span class="hljs-type">ItemViewModel</span>&lt;<span class="hljs-type">Person</span>&gt;</span>() {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> name</span> = bind(Person::nameProperty) 
    <span class="hljs-variable"><span class="hljs-keyword">val</span> title</span> = bind(Person::titleProperty)
}
</code></pre>
<p>You will notice we no longer need to pass in the <code>var person: Person</code> in the constructor. The <code>ItemViewModel</code> now has an observable property called<br><code>itemProperty</code> and getters/setters via the <code>item</code> property. Whenever you assign something to <code>item</code> or via <code>itemProperty.value</code>, the model is automatically rebound for you. There is also an observable <code>empty</code> boolean value you can use to check if the <code>ItemViewModel</code> is currently holding a <code>Person</code>.</p>
<p>The binding expressions need to take into account that it might not represent any item at the time of binding. That is why the binding expressions above now use the null safe operator.</p>
<p>We just got rid of some boiler plate, but the <code>ItemViewModel</code> gives us a lot more functionality. Remember how we bound the selected person from the <code>TableView</code> to our model earlier?</p>
<pre><code class="lang-kotlin"><span class="hljs-comment">// Update the person inside the view model on selection change</span>
model.rebindOnChange(this) { selectedPerson -&gt;
    person = selectedPerson ?: Person()
}
</code></pre>
<p>Using the <code>ItemViewModel</code> this can be rewritten:</p>
<pre><code class="lang-kotlin"><span class="hljs-comment">// Update the person inside the view model on selection change</span>
bindSelected(model)
</code></pre>
<p>This will effectively attach the listener we had to write manually before and make sure that the <code>TableView</code> selection is visible in the model.</p>
<p>The <code>save()</code> function will now also be slightly different, since there is no <code>person</code> property in our model:</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> {</span>
    model.commit()
    <span class="hljs-variable"><span class="hljs-keyword">val</span> person</span> = model.item
    println(<span class="hljs-string">&quot;Saving ${person.name} / ${person.title}&quot;</span>)
}
</code></pre>
<p>The person is extracted from the <code>itemProperty</code> using the <code>item</code> getter.</p>
<h3 id="oncommit-callback">OnCommit callback</h3>
<p>Sometimes it&apos;s desirable to do a specific action after the model was successfully committed.<br>The <code>ViewModel</code> offers two callbacks, <code>onCommit</code> and <code>onCommit(commits: List&lt;Commit&gt;)</code>, for that.</p>
<p>The first function<code>onCommit</code>, has no parameters and will be called after a successful commit,<br>right before the optional <code>successFn</code> is invoked (see: <code>commit</code>).<br>The second function will be called in the same order and with the addition of passing a list of committed properties along.<br>Each <code>Commit</code> in the list, consists of the original <code>ObservableValue</code>, the <code>oldValue</code> and the <code>newValue</code><br>and a property <code>changed</code>, to signal if the <code>oldValue</code> is different then the <code>newValue</code>.</p>
<p>Let&apos;s look at an example how we can retrieve only the changed objects and print them to <code>stdout</code>.</p>
<p>To find out which object changed we defined a little extension function, which will find the given property and if it was changed will return the old and new value or null if there was no change.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonModel</span> : <span class="hljs-type">ItemViewModel</span>&lt;<span class="hljs-type">Person</span>&gt;</span>() {

    <span class="hljs-variable"><span class="hljs-keyword">val</span> firstname</span> = bind(Person::firstName)
    <span class="hljs-variable"><span class="hljs-keyword">val</span> lastName</span> = bind(Person::lastName)

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCommit</span><span class="hljs-params">(commits: <span class="hljs-type">List&lt;Commit&gt;</span>)</span> {</span>
       <span class="hljs-comment">// The println will only be called if findChanged is not null </span>
       commits.findChanged(firstName)?.let { println(<span class="hljs-string">&quot;First-Name changed from ${it.second} to ${it.first}&quot;</span>)}
       commits.findChanged(lastName)?.let { println(<span class="hljs-string">&quot;Last-Name changed from ${it.second} to ${it.first}&quot;</span>)}
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;Commit&gt;</span>.<span class="hljs-title">findChanged</span><span class="hljs-params">(ref: <span class="hljs-type">Property&lt;T&gt;</span>)</span>: Pair<span class="hljs-type">&lt;T, T&gt;</span>? {</span>
        <span class="hljs-variable"><span class="hljs-keyword">val</span> commit</span> = find { it.property == ref &amp;&amp; it.changed}
        <span class="hljs-keyword">return</span> commit?.let { (it.newValue <span class="hljs-keyword">as</span> T) to (it.oldValue <span class="hljs-keyword">as</span> T) }
    }
}
</code></pre>
<h2 id="injectable-models">Injectable Models</h2>
<p>Most commonly you will not have both the <code>TableView</code> and the editor in the same <code>View</code>. We would then need to access the <code>ViewModel</code> from at least two different views, one for the <code>TableView</code> and one for the form. Luckily, the <code>ViewModel</code> is injectable, so we can rewrite our editor example and split the two views:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonList</span> : <span class="hljs-type">View</span></span>(<span class="hljs-string">&quot;Person List&quot;</span>) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> persons</span> = listOf(Person(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Manager&quot;</span>), Person(<span class="hljs-string">&quot;Jay&quot;</span>, <span class="hljs-string">&quot;Worker bee&quot;</span>)).observable()
    <span class="hljs-variable"><span class="hljs-keyword">val</span> model</span> : PersonModel by inject()

    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = tableview(persons) {
        title = <span class="hljs-string">&quot;Person&quot;</span>
        column(<span class="hljs-string">&quot;Name&quot;</span>, Person::nameProperty)
        column(<span class="hljs-string">&quot;Title&quot;</span>, Person::titleProperty)
        bindSelected(model)
    }
}
</code></pre>
<p>The person <code>TableView</code> now becomes a lot cleaner and easier to reason with. In a real application the list of persons would probably come from a controller or a remoting call though. The model is simply injected into the <code>View</code>, and we will do the same for the editor:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonEditor</span> : <span class="hljs-type">View</span></span>(<span class="hljs-string">&quot;Person Editor&quot;</span>) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> model</span> : PersonModel by inject()

    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = form {
        fieldset(<span class="hljs-string">&quot;Edit person&quot;</span>) {
            field(<span class="hljs-string">&quot;Name&quot;</span>) {
                textfield(model.name)
            }
            field(<span class="hljs-string">&quot;Title&quot;</span>) {
                textfield(model.title)
            }
           button(<span class="hljs-string">&quot;Save&quot;</span>) {
                enableWhen(model.dirty)
                action {
                    save()
                }
            }
            button(<span class="hljs-string">&quot;Reset&quot;</span>).action {
                model.rollback()
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> {</span>
        model.commit()
        println(<span class="hljs-string">&quot;Saving ${model.item.name} / ${model.item.title}&quot;</span>)
    }
}
</code></pre>
<p>The injected instance of the model will be the exact same one in both views. Again, in a real application the save call would probably be offloaded<br>to a controller asynchronously.</p>
<h2 id="when-to-use-viewmodel-vs-itemviewmodel">When to Use <code>ViewModel</code> vs <code>ItemViewModel</code></h2>
<p>This chapter has progressed from the low-level implementation <code>ViewModel</code> into a streamlined <code>ItemViewModel</code>. You might wonder if there are any use cases for inheriting from<br><code>ViewModel</code> instead of <code>ItemViewModel</code> at all. The answer is that while you would typically extend <code>ItemViewModel</code> more than 90% of the time, there are some use cases where it does not make sense. Since ViewModels can be injected and used to keep navigational state and overall UI state, you might use it for situations where you do not have a single domain object - you could have multiple domain objects or just a collection of loose properties. In this use case the <code>ItemViewModel</code> does not make any sense, and you might implement the <code>ViewModel</code> directly. For common cases though, <code>ItemViewModel</code> is your best friend.</p>
<blockquote>
<p>There is one potential issue with this approach. If we want to display multiple &quot;pairs&quot; of lists and forms, perhaps in different windows, we need a way to separate and bind the model belonging to a spesific pair of list and form. There are many ways to deal with that, but one tool very well suited for this is the scopes. Check out the scope documentation for more information about this approach.</p>
</blockquote>
<h1 id="validation">Validation</h1>
<p>Almost every application needs to check that the input supplied by the user conforms to a set of rules or are otherwise acceptable. TornadoFX sports an extensible validation and decoration framework.</p>
<p>We will first look at validation as a standalone feature before we integrate it with the <code>ViewModel</code>.</p>
<h2 id="under-the-hood">Under the Hood</h2>
<p>The following explanation is a bit verbose and does not reflect the way you would write validation code in your application. This section will provide you with a solid understanding of how validation works and how the individual pieces fit together.</p>
<h3 id="validator">Validator</h3>
<p>A <code>Validator</code> knows how to inspect user input of a specified type and will return a <code>ValidationMessage</code> with a <code>ValidationSeverity</code> describing how the input compares to the expected input for a specific control. If a <code>Validator</code> deems that there is nothing to report for an input value, it returns <code>null</code>. A text message can optionally accompany the <code>ValidationMessage</code>, and would normally be displayed by the <code>Decorator</code> configured in the <code>ValidationContext</code>. We will cover more on decorators later.</p>
<p>The following severity levels are supported:</p>
<ul>
<li><code>Error</code> - Input was not accepted</li>
<li><code>Warning</code> - Input is not ideal, but accepted</li>
<li><code>Success</code> - Input is accepted</li>
<li><code>Info</code> - Input is accepted</li>
</ul>
<p>There are multiple severity levels representing successful input to easier provide the contextually correct feedback in most cases. For example, you might want to give an informational message for a field no matter the input value, or specifically mark fields with a green checkbox when they are entered. The only severity that will result in an invalid status is the <code>Error</code> level.</p>
<h3 id="validationtrigger">ValidationTrigger</h3>
<p>By default validation will happen when the input value changes. The input value is always an <code>ObservableValue&lt;T&gt;</code>, and the default trigger simply listens for changes. You can however choose<br>to validate when the input field looses focus, or when a save button is clicked for instance. The following ValidationTriggers can be configured for each validator:</p>
<ul>
<li><code>OnChange</code> - Validate when input value changes, optionally after a given delay in milliseconds</li>
<li><code>OnBlur</code> - Validate when the input field looses focus</li>
<li><code>Never</code> - Only validate when <code>ValidationContext.validate()</code> is called</li>
</ul>
<h3 id="validationcontext">ValidationContext</h3>
<p>Normally you would validate user input from multiple controls or input fields at once. You can gather these validators in a <code>ValidationContext</code> so you can check if all validators are valid, or ask the validation context to perform validation for all fields at any given time. The context also controls what kind of decorator will be used to convey the validation message for each field. See the Ad Hoc validation example below.</p>
<h2 id="decorator">Decorator</h2>
<p>The <code>decorationProvider</code> of a <code>ValidationContext</code> is in charge of providing feedback when a <code>ValidationMessage</code> is associated with an input. By default this is an instance of <code>SimpleMessageDecorator</code>which will mark the input field with a colored triangle in the topper left corner and display a popup with the message while the input has focus.</p>
<p><img src="https://i.imgur.com/3tw57fS.png" alt=""></p>
<p><strong>Figure 11.2</strong> The default decorator showing a required field validation message</p>
<p>If you don&apos;t like the default decorator look you can easily create your own by implementing the <code>Decorator</code> interface:</p>
<pre><code class="lang-kotlin">interface Decorator {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">decorate</span><span class="hljs-params">(node: <span class="hljs-type">Node</span>)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">undecorate</span><span class="hljs-params">(node: <span class="hljs-type">Node</span>)</span></span>
}
</code></pre>
<p>You can assign your decorator to a given <code>ValidationContext</code> like this:</p>
<pre><code class="lang-kotlin">context.decorationProvider = MyDecorator()
</code></pre>
<p><strong>Tip: You can create a decorator that applies CSS style classes to your inputs instead of overlaying other nodes to provide feedback.</strong></p>
<h2 id="ad-hoc-validation">Ad Hoc Validation</h2>
<p>While you will probably never do this in a real application, it is possible to set up a <code>ValidationContext</code> and apply validators to it manually. The following<br>example is actually taken from the internal tests of the framework. It illustrates the concept, but is not a practical pattern in an application.</p>
<pre><code class="lang-kotlin"><span class="hljs-comment">// Create a validation context</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> context</span> = ValidationContext()

<span class="hljs-comment">// Create a TextField we can attach validation to</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> input</span> = TextField()

<span class="hljs-comment">// Define a validator that accepts input longer than 5 chars</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> validator</span> = context.addValidator(input, input.textProperty()) {
    <span class="hljs-keyword">if</span> (it!!.length <span class="hljs-type">&lt; 5) error(&quot;Too short&quot;) else null
}

// Simulate user input
input.text = &quot;abc&quot;

// Validation should fail
assertFalse(validator.validate())

// Extract the validation result
val result = validator.result

// The severity should be error
assertTrue(result is ValidationMessage &amp;&amp; result.severity == ValidationSeverity.Error)

// Confirm valid input passes validation
input.text = &quot;longvalue&quot;
assertTrue(validator.validate())
assertNull(validator.result)
</span></code></pre>
<p>Take special note of the last parameter to the <code>addValidator</code> call. This is the actual validation logic. The function is passed the<br>current input for the property it validates and must return null if there are no messages, or an instance of <code>ValidationMessage</code> if something<br>is noteworthy about the input. A message with severity <code>Error</code> will cause the validation to fail. As you can see, you don&apos;t need to instantiate<br>a ValidationMessage yourself, simply use one of the functions <code>error</code>, <code>warning</code>, <code>success</code> or <code>info</code> instead.</p>
<h1 id="validation-with-viewmodel">Validation with ViewModel</h1>
<p>Every ViewModel contains a <code>ValidationContext</code>, so you don&apos;t need to instantiate one yourself. The Validation framework integrates with the type<br>safe builders as well, and even provides some built in validators, like the <code>required</code> validator. Going back to our person editor, we can<br>make the input fields required with this simple change:</p>
<pre><code class="lang-kotlin">field(<span class="hljs-string">&quot;Name&quot;</span>) {
    textfield(model.name).required()
}
</code></pre>
<p>That&apos;s all there is to it. The required validator optionally takes a message that will be presented to the user if the validation fails. The default text<br>is &quot;This field is required&quot;.</p>
<p>Instead of using the built in <code>required</code> validator we can express the same thing manually:</p>
<pre><code class="lang-kotlin">field(<span class="hljs-string">&quot;Name&quot;</span>) {
    textfield(model.name).validator {
        <span class="hljs-keyword">if</span> (it.isNullOrBlank()) error(<span class="hljs-string">&quot;The name field is required&quot;</span>) <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
    }
}
</code></pre>
<p>If you want to further customize the textfield, you might want to add another set of curly braces:</p>
<pre><code class="lang-kotlin">field(<span class="hljs-string">&quot;Name&quot;</span>) {
    textfield(model.name) {
        <span class="hljs-comment">// Manipulate the text field here</span>
        validator {
            <span class="hljs-keyword">if</span> (it.isNullOrBlank()) error(<span class="hljs-string">&quot;The name field is required&quot;</span>) <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
        }
    }
}
</code></pre>
<h2 id="binding-buttons-to-validation-state">Binding buttons to validation state</h2>
<p>You might want to only enable certain buttons in your forms when the input is valid. The <code>model.valid</code> property can be used for this purpose. Since<br>the default validation trigger is <code>OnChange</code>, the valid state would only be accurate when you first try to commit the model. However, if you want<br>to bind a button to the <code>valid</code> state of the model you can call <code>model.validate(decorateErrors = false)</code> to force all validators to report their results without<br>actually showing any validation errors to the user.</p>
<pre><code class="lang-kotlin">field(<span class="hljs-string">&quot;username&quot;</span>) {
    textfield(username).required()
}
field(<span class="hljs-string">&quot;password&quot;</span>) {
    passwordfield(password).required()
}
buttonbar {
    button(<span class="hljs-string">&quot;Login&quot;</span>, ButtonBar.ButtonData.OK_DONE) {
        enableWhen(model.valid)
        action {
            model.commit {
                doLogin()
            }
        }
    }
}
<span class="hljs-comment">// Force validators to update the `model.valid` property</span>
model.validate(decorateErrors = <span class="hljs-literal">false</span>)
</code></pre>
<p>Notice how the login button&apos;s enabled state is bound to the enabled state of the model via <code>enableWhen { model.valid }</code> call. After all<br>the fields and validators are configured, the <code>model.validate(decorateErrors = false)</code> make sure the valid state of the model is updated<br>without triggering error decorations on the fields that fail validation. The decorators will kick in on value change by default, unless you<br>override the <code>trigger</code> parameter to <code>validator</code>. The <code>required()</code> build in validator also accepts this parameter. For example, to run the validator<br>only when the input field looses focus you can call <code>textfield(username).required(ValidationTrigger.OnBlur)</code>.</p>
<h1 id="validation-in-dialogs">Validation in dialogs</h1>
<p>The <code>dialog</code> builder creates a window with a form and a fieldset and let&apos;s you start adding fields to it. Some times you don&apos;t have a ViewModel for such cases, but you might still want to<br>use the features it provides. For such situations you can instantiate a ViewModel inline and hook up one or more properties to it. Here is an example dialog that requires the user to enter some input in a textarea:</p>
<pre><code class="lang-kotlin">dialog(<span class="hljs-string">&quot;Add note&quot;</span>) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> model</span> = ViewModel()
    <span class="hljs-variable"><span class="hljs-keyword">val</span> note</span> = model.bind { SimpleStringProperty() }

    field(<span class="hljs-string">&quot;Note&quot;</span>) {
        textarea(note) {
            required()
            whenDocked { requestFocus() }
        }
    }
    buttonbar {
        button(<span class="hljs-string">&quot;Save note&quot;</span>).action {
            model.commit { doSave() }
        }
    }
}
</code></pre>
<p><img src="https://i.imgur.com/zR0kf3U.png" alt=""></p>
<p><strong>Figure 11.3</strong> A dialog with a inline ViewModel context</p>
<p>Notice how the <code>note</code> property is connected to the context by specifying it&apos;s bean parameter. This is crucial for making the field validation available.</p>
<h2 id="partial-commit">Partial commit</h2>
<p>It&apos;s also possible to do a partial commit by suppling a list of fields you want to commit to avoid committing everything. This can be convenient in situations where you edit the same<br>ViewModel instance from different Views, for example in a Wizard. See the Wizard chapter for more information about partial commit, and the corresponding partial validation features.</p>
<h1 id="tablevieweditmodel">TableViewEditModel</h1>
<p>If you are pressed for screen real estate and do not have space for a master/detail setup with a <code>TableView</code>, an effective option is to edit the <code>TableView</code> directly. By enabling a few streamlined features in TornadoFX, you can not only enable easy cell editing but also enable dirty state tracking, committing, and rollback. By calling <code>enableCellEditing()</code> and <code>enableDirtyTracking()</code>, as well as accessing the <code>tableViewEditModel</code> property of a <code>TableView</code>, you can easily enable this functionality.</p>
<p>When you edit a cell, a blue flag will indicate its dirty state. Calling <code>rollback()</code> will revert dirty cells to their original values, whereas <code>commit()</code> will set the current values as the new baseline (and remove all dirty state history).</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">import</span> tornadofx.*

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span>: <span class="hljs-type">App</span></span>(MyView::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> : <span class="hljs-type">View</span></span>(<span class="hljs-string">&quot;My View&quot;</span>) {

    <span class="hljs-variable"><span class="hljs-keyword">val</span> controller</span>: CustomerController by inject()
    <span class="hljs-variable"><span class="hljs-keyword">var</span> tableViewEditModel</span>: TableViewEditModel<span class="hljs-type">&lt;Customer&gt;</span> by singleAssign()

    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> =  borderpane {
        top = buttonbar {
            button(<span class="hljs-string">&quot;COMMIT&quot;</span>).setOnAction {
                tableViewEditModel.commit()
            }
            button(<span class="hljs-string">&quot;ROLLBACK&quot;</span>).setOnAction {
                tableViewEditModel.rollback()
            }
        }
        center = tableview<span class="hljs-type">&lt;Customer&gt;</span> {

            items = controller.customers
            isEditable = <span class="hljs-literal">true</span>

            column(<span class="hljs-string">&quot;ID&quot;</span>,Customer::idProperty)
            column(<span class="hljs-string">&quot;FIRST NAME&quot;</span>, Customer::firstNameProperty).makeEditable()
            column(<span class="hljs-string">&quot;LAST NAME&quot;</span>, Customer::lastNameProperty).makeEditable()

            enableCellEditing() <span class="hljs-comment">//enables easier cell navigation/editing</span>
            enableDirtyTracking() <span class="hljs-comment">//flags cells that are dirty</span>

            tableViewEditModel = editModel
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerController</span> : <span class="hljs-type">Controller</span></span>() {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> customers</span> = listOf(
            Customer(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Marley&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>),
            Customer(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Schmidt&quot;</span>, <span class="hljs-string">&quot;Ally&quot;</span>),
            Customer(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Johnson&quot;</span>, <span class="hljs-string">&quot;Eric&quot;</span>)
    ).observable()
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span></span>(id: <span class="hljs-keyword">Int</span>, lastName: String, firstName: String) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> lastNameProperty</span> = SimpleStringProperty(this, <span class="hljs-string">&quot;lastName&quot;</span>, lastName)
    <span class="hljs-variable"><span class="hljs-keyword">var</span> lastName by lastNameProperty
    <span class="hljs-keyword">val</span> firstNameProperty</span> = SimpleStringProperty(this, <span class="hljs-string">&quot;firstName&quot;</span>, firstName) 
    <span class="hljs-variable"><span class="hljs-keyword">var</span> firstName by firstNameProperty
    <span class="hljs-keyword">val</span> idProperty</span> = SimpleIntegerProperty(this, <span class="hljs-string">&quot;id&quot;</span>, id) 
    <span class="hljs-variable"><span class="hljs-keyword">var</span> id by idProperty
}
</span></code></pre>
<p><img src="https://i.imgur.com/rEyYzyV.png" alt=""></p>
<p><strong>Figure 11.4</strong> A <code>TableView</code> with dirty state tracking, with <code>rollback()</code> and <code>commit()</code> functionality.</p>
<p>Note also there are many other helpful properties and functions on the <code>TableViewEditModel</code>. The <code>items</code> property is an <code>ObservableMap&lt;S, TableColumnDirtyState&lt;S&gt;&gt;</code> mapping the dirty state of each record item <code>S</code>. If you want to filter out and commit only dirty records so you can persist them somewhere, you can have your &quot;Commit&quot; <code>Button</code> perform this action instead.</p>
<pre><code class="lang-kotlin">button(<span class="hljs-string">&quot;COMMIT&quot;</span>).action {
    tableViewEditModel.items.asSequence()
            .filter { it.value.isDirty }
            .forEach {
                println(<span class="hljs-string">&quot;Committing ${it.key}&quot;</span>)
                it.value.commit()
            }
}
</code></pre>
<p>There are also <code>commitSelected()</code> and <code>rollbackSelected()</code> to only commit or rollback the selected records in the <code>TableView</code>.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="10. FXML.html" class="navigation navigation-prev " aria-label="Previous page: 10. FXML">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="12. TornadoFX IDEA Plugin.html" class="navigation navigation-next " aria-label="Next page: 12. TornadoFX IDEA Plugin">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"11. Editing Models and Validation","level":"1.2.11","depth":2,"next":{"title":"12. TornadoFX IDEA Plugin","level":"1.2.12","depth":2,"path":"part1/12. TornadoFX IDEA Plugin.md","ref":"part1/12. TornadoFX IDEA Plugin.md","articles":[]},"previous":{"title":"10. FXML","level":"1.2.10","depth":2,"path":"part1/10. FXML.md","ref":"part1/10. FXML.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"part1/11. Editing Models and Validation.md","mtime":"2020-02-13T15:46:37.950Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-02-13T15:47:39.413Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

