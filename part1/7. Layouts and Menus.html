
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>7. Layouts and Menus · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="8. Charts.html" />
    
    
    <link rel="prev" href="6. CSS.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="0. Subsection.html">
            
                <a href="0. Subsection.html">
            
                    
                    第一部分: TornadoFX 基本介紹
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="1. Why TornadoFX.html">
            
                <a href="1. Why TornadoFX.html">
            
                    
                    1. 為什麼選擇 TornadoFX?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="2. Setting Up.html">
            
                <a href="2. Setting Up.html">
            
                    
                    2. 配置
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="3. Components.html">
            
                <a href="3. Components.html">
            
                    
                    3. 組件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="4. Basic Controls.html">
            
                <a href="4. Basic Controls.html">
            
                    
                    4. Basic Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="5. Data Controls.html">
            
                <a href="5. Data Controls.html">
            
                    
                    5. Data Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="6. CSS.html">
            
                <a href="6. CSS.html">
            
                    
                    6. Type Safe CSS
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.7" data-path="7. Layouts and Menus.html">
            
                <a href="7. Layouts and Menus.html">
            
                    
                    7. Layouts and Menus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="8. Charts.html">
            
                <a href="8. Charts.html">
            
                    
                    8. Charts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="9. Shapes and Animation.html">
            
                <a href="9. Shapes and Animation.html">
            
                    
                    9. Shapes and Animation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="10. FXML.html">
            
                <a href="10. FXML.html">
            
                    
                    10. FXML
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="11. Editing Models and Validation.html">
            
                <a href="11. Editing Models and Validation.html">
            
                    
                    11. Editing Models and Validation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="12. TornadoFX IDEA Plugin.html">
            
                <a href="12. TornadoFX IDEA Plugin.html">
            
                    
                    12. TornadoFX IDEA Plugin
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../part2/0. Subsection.html">
            
                <a href="../part2/0. Subsection.html">
            
                    
                    Part 2: TornadoFX Advanced Features
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../part2/Property Delegates.html">
            
                <a href="../part2/Property Delegates.html">
            
                    
                    Property Delegates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../part2/Advanced Data Controls.html">
            
                <a href="../part2/Advanced Data Controls.html">
            
                    
                    Advanced Data Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../part2/OSGi.html">
            
                <a href="../part2/OSGi.html">
            
                    
                    OSGi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../part2/Scopes.html">
            
                <a href="../part2/Scopes.html">
            
                    
                    Scopes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../part2/EventBus.html">
            
                <a href="../part2/EventBus.html">
            
                    
                    EventBus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../part2/Workspaces.html">
            
                <a href="../part2/Workspaces.html">
            
                    
                    Workspaces
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../part2/Layout Debugger.html">
            
                <a href="../part2/Layout Debugger.html">
            
                    
                    Layout Debugger
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../part2/Internationalization.html">
            
                <a href="../part2/Internationalization.html">
            
                    
                    Internationalization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../part2/Config Settings and State.html">
            
                <a href="../part2/Config Settings and State.html">
            
                    
                    Config Settings and State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../part2/JSON and REST.html">
            
                <a href="../part2/JSON and REST.html">
            
                    
                    JSON and REST
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="../part2/Dependency Injection.html">
            
                <a href="../part2/Dependency Injection.html">
            
                    
                    Dependency Injection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="../part2/Wizard.html">
            
                <a href="../part2/Wizard.html">
            
                    
                    Wizard
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="../part2/Integration.html">
            
                <a href="../part2/Integration.html">
            
                    
                    Integrating with other tech
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../part3/0. Subsection.html">
            
                <a href="../part3/0. Subsection.html">
            
                    
                    Part 3: Cook Book
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../part3/Snippets.html">
            
                <a href="../part3/Snippets.html">
            
                    
                    Snippets
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >7. Layouts and Menus</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="layouts-and-menus">Layouts and Menus</h1>
<p>Complex UI&apos;s require many controls. It is likely these controls need to be grouped, positioned, and sized with set policies. Fortunately TornadoFX streamlines many layouts that come with JavaFX, as well as features its own proprietary <code>Form</code> layout.</p>
<p>TornadoFX also has type-safe builders to create menus in a highly structured, declarative way. Menus can be especially cumbersome to build using conventional JavaFX code, and Kotlin really shines in this department.</p>
<h2 id="builders-for-layouts">Builders for Layouts</h2>
<p>Layouts group controls and set policies about their sizing and positioning behavior. Technically, layouts themselves are controls so therefore you can nest layouts inside layouts. This is critical for building complex UI&apos;s, and TornadoFX makes maintenance of UI code easier by visibly showing the nested relationships.</p>
<h3 id="vbox">VBox</h3>
<p>A <code>VBox</code> stacks controls vertically in the order they are declared inside its block (Figure 7.1).</p>
<pre><code class="lang-kotlin">vbox {
    button(<span class="hljs-string">&quot;Button 1&quot;</span>).setOnAction {
        println(<span class="hljs-string">&quot;Button 1 Pressed&quot;</span>)
    }
    button(<span class="hljs-string">&quot;Button 2&quot;</span>).setOnAction {
        println(<span class="hljs-string">&quot;Button 2 Pressed&quot;</span>)
    }
}
</code></pre>
<p><strong>Figure 7.1</strong></p>
<p><img src="https://i.imgur.com/QUdBHkA.png" alt=""></p>
<p>You can also call <code>vboxConstraints()</code> within a child&apos;s block to change the margin and vertical growing behaviors of the <code>VBox</code>.</p>
<pre><code class="lang-kotlin">vbox {
    button(<span class="hljs-string">&quot;Button 1&quot;</span>) {
         vboxConstraints {
            marginBottom = <span class="hljs-number">20.0</span>
            vGrow = Priority.ALWAYS
          }
    }
    button(<span class="hljs-string">&quot;Button 2&quot;</span>)
}
</code></pre>
<p>You can use a shorthand extension property for <code>vGrow</code> without calling <code>vboxConstraints()</code>.</p>
<pre><code class="lang-kotlin">vbox {
    button(<span class="hljs-string">&quot;Button 1&quot;</span>) {
           vGrow = Priority.ALWAYS
    }
    button(<span class="hljs-string">&quot;Button 2&quot;</span>)
}
</code></pre>
<h3 id="hbox">HBox</h3>
<p><code>HBox</code> behaves almost identically to <code>VBox</code>, but it stacks all controls horizontally left-to-right in the order declared in its block.</p>
<pre><code class="lang-kotlin">hbox {
    button(<span class="hljs-string">&quot;Button 1&quot;</span>).setOnAction {
        println(<span class="hljs-string">&quot;Button 1 Pressed&quot;</span>)
    }
    button(<span class="hljs-string">&quot;Button 2&quot;</span>).setOnAction {
        println(<span class="hljs-string">&quot;Button 2 Pressed&quot;</span>)
    }
}
</code></pre>
<p><strong>Figure 7.2</strong></p>
<p><img src="https://i.imgur.com/cVMUYR8.png" alt=""></p>
<p>You can also call <code>hboxconstraints()</code> within the a child&apos;s block to change the margin and horizontal growing behaviors of the <code>HBox</code>.</p>
<pre><code class="lang-kotlin">hbox {
    button(<span class="hljs-string">&quot;Button 1&quot;</span>) {
        hboxConstraints {
                marginRight = <span class="hljs-number">20.0</span>
          hGrow = Priority.ALWAYS
      }
    }
    button(<span class="hljs-string">&quot;Button 2&quot;</span>)
}
</code></pre>
<p>You can use a shorthand extension property for <code>hGrow</code> without calling <code>hboxConstraints()</code>.</p>
<pre><code class="lang-kotlin">hbox {
    button(<span class="hljs-string">&quot;Button 1&quot;</span>) {
          hGrow = Priority.ALWAYS
    }
  button(<span class="hljs-string">&quot;Button 2&quot;</span>)
}
</code></pre>
<h3 id="flowpane">FlowPane</h3>
<p>The <code>FlowPane</code> lays out controls left-to-right and wraps to the next line on the boundary. For example, say you added 100 buttons to a <code>FlowPane</code> (Figure 7.3). You will notice it simply lays out buttons from left-to-right, and when it runs out of room it moves to the &quot;next line&quot;.</p>
<pre><code class="lang-kotlin">flowpane {
   <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.100</span>) {
        button(i.toString()) {
            setOnAction { println(<span class="hljs-string">&quot;You pressed button $i&quot;</span>) }
        }
   }
}
</code></pre>
<p><strong>Figure 7.3</strong></p>
<p><img src="https://i.imgur.com/d9tP0zi.png" alt=""></p>
<p>Notice also when you resize the window, the <code>FlowLayout</code> will re-wrap the buttons so they all can fit (Figure 7.4)</p>
<p><strong>Figure 7.4</strong></p>
<p><img src="https://i.imgur.com/hhnSrDB.png" alt=""></p>
<p>The <code>FlowLayout</code> is not used often because it is often simplistic for handling a large number of controls, but it comes in handy for certain situations and can be used inside other layouts.</p>
<h3 id="borderpane">BorderPane</h3>
<p>The <code>BorderPane</code> is a highly useful layout that divides controls into 5 regions: <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>, and <code>center</code>. Many UI&apos;s can easily be built using two or more of these regions to hold controls (Figure 7.5).</p>
<pre><code class="lang-kotlin">borderpane {
    top = label(<span class="hljs-string">&quot;TOP&quot;</span>) {
        useMaxWidth = <span class="hljs-literal">true</span>
        style {
            backgroundColor += Color.RED
        }
    }

    bottom = label(<span class="hljs-string">&quot;BOTTOM&quot;</span>) {
        useMaxWidth = <span class="hljs-literal">true</span>
        style {
            backgroundColor += Color.BLUE
        }
    }

    left = label(<span class="hljs-string">&quot;LEFT&quot;</span>) {
        useMaxWidth = <span class="hljs-literal">true</span>
        style {
            backgroundColor += Color.GREEN
        }
    }

    right = label(<span class="hljs-string">&quot;RIGHT&quot;</span>) {
        useMaxWidth = <span class="hljs-literal">true</span>
        style {
            backgroundColor += Color.PURPLE
        }
    }

    center = label(<span class="hljs-string">&quot;CENTER&quot;</span>) {
        useMaxWidth = <span class="hljs-literal">true</span>
        style {
            backgroundColor += Color.YELLOW
        }
    }
}
</code></pre>
<p><strong>FIGURE 7.5</strong></p>
<p><img src="https://i.imgur.com/ewjk2Gg.png" alt=""></p>
<p>You will notice that the <code>top</code> and <code>bottom</code> regions take up the entire horizontal space, while <code>left</code>, <code>center</code>, and <code>right</code> must share the available horizontal space. But <code>center</code> is entitled to any extra available space (vertically and horizontally), making it ideal to hold large controls like <code>TableView</code>. For instance, you may vertically stack some buttons in the <code>left</code> region and put a <code>TableView</code> in the <code>center</code> region (Figure 7.6).</p>
<pre><code class="lang-kotlin">borderpane {
    left = vbox {
        button(<span class="hljs-string">&quot;REFRESH&quot;</span>)
        button(<span class="hljs-string">&quot;COMMIT&quot;</span>)
    }

    center  = tableview<span class="hljs-type">&lt;Person&gt;</span> {
        items = listOf(
                Person(<span class="hljs-string">&quot;Joe Thompson&quot;</span>, <span class="hljs-number">33</span>),
                Person(<span class="hljs-string">&quot;Sam Smith&quot;</span>, <span class="hljs-number">29</span>),
                Person(<span class="hljs-string">&quot;Nancy Reams&quot;</span>, <span class="hljs-number">41</span>)
        ).observable()

        column(<span class="hljs-string">&quot;NAME&quot;</span>,Person::name)
        column(<span class="hljs-string">&quot;AGE&quot;</span>,Person::age)
    }
}
</code></pre>
<p><strong>Figure 7.6</strong></p>
<p><img src="https://i.imgur.com/uLS5bGJ.png" alt=""></p>
<p><code>BorderPane</code> is a layout you will likely want to use often because it simplifies many complex UI&apos;s. The <code>top</code> region is commonly used to hold a <code>MenuBar</code> and the <code>bottom</code> region often holds a status bar of some kind. You have already seen <code>center</code> hold the focal control such as a <code>TableView</code>, and <code>left</code> and <code>right</code> hold side panels with any peripheral controls (like Buttons or Toolbars) not appropriate for the <code>MenuBar</code>. We will learn about Menus later in this section.</p>
<h3 id="form-builder">Form Builder</h3>
<p>TornadoFX has a helpful <code>Form</code> control to handle a large number of user inputs. Having several input fields to take user information is common and JavaFX does not have a built-in solution to streamline this. To remedy this, TornadoFX has a builder to declare a <code>Form</code> with any number of fields (Figure 7.7).</p>
<pre><code class="lang-kotlin">form {
    fieldset(<span class="hljs-string">&quot;Personal Info&quot;</span>) {
        field(<span class="hljs-string">&quot;First Name&quot;</span>) {
            textfield()
        }
        field(<span class="hljs-string">&quot;Last Name&quot;</span>) {
            textfield()
        }
        field(<span class="hljs-string">&quot;Birthday&quot;</span>) {
            datepicker()
        }
    }
    fieldset(<span class="hljs-string">&quot;Contact&quot;</span>) {
        field(<span class="hljs-string">&quot;Phone&quot;</span>) {
            textfield()
        }
        field(<span class="hljs-string">&quot;Email&quot;</span>) {
            textfield()
        }
    }
    button(<span class="hljs-string">&quot;Commit&quot;</span>) {
        action { println(<span class="hljs-string">&quot;Wrote to database!&quot;</span>)}
    }
}
</code></pre>
<p><strong>Figure 7.7</strong></p>
<p><img src="https://i.imgur.com/R3RumAv.png" alt=""> <img src="https://i.imgur.com/fLrIbzN.png" alt=""></p>
<p>Awesome right? You can specify one or more controls for each of the fields, and the <code>Form</code> will render the groupings and labels for you. </p>
<p>You can choose to lay out the label above the inputs as well:</p>
<pre><code class="lang-kotlin">fieldset(<span class="hljs-string">&quot;FieldSet&quot;</span>, labelPosition = VERTICAL)
</code></pre>
<p>Each <code>field</code> represents a container with the label and another container for the input fields you add inside it. The input container is by default an <code>HBox</code>, meaning that
 multiple inputs within a single field will be laid out next to each other. You can specify the <code>orientation</code> parameter to a field to make it lay out multiple inputs 
 below each other. Another use case for Vertical orientation is to allow an input to grow as the form expands vertically. This is handy for displaying TextAreas in Forms:</p>
<pre><code class="lang-kotlin">form {
    fieldset(<span class="hljs-string">&quot;Feedback Form&quot;</span>, labelPosition = VERTICAL) {
        field(<span class="hljs-string">&quot;Comment&quot;</span>, VERTICAL) {
            textarea {
                prefRowCount = <span class="hljs-number">5</span>
                vgrow = Priority.ALWAYS
            }
        }
        buttonbar {
            button(<span class="hljs-string">&quot;Send&quot;</span>)
        }
    }
}
</code></pre>
<p><strong>Figure 7.8</strong></p>
<p><img src="https://i.imgur.com/u670aq3.png" alt=""></p>
<p>The example above also uses the <code>buttonbar</code> builder to create a special field with no label while retaining the label indent so the buttons line up under the inputs.</p>
<p>You bind each input to a model, and you can leave the rendering of the control layouts to the <code>Form</code>. For this reason you will likely want to use this over the <code>GridPane</code> if possible, which we will cover next.</p>
<h4 id="nesting-layouts-inside-a-form">Nesting layouts inside a Form</h4>
<p>You can wrap both fieldsets and fields with any layout container of your choosing to create complex form layouts.</p>
<pre><code class="lang-kotlin">form {
    hbox(<span class="hljs-number">20</span>) {
        fieldset(<span class="hljs-string">&quot;Left FieldSet&quot;</span>) {
            hbox(<span class="hljs-number">20</span>) {
                vbox {
                    field(<span class="hljs-string">&quot;Field l1a&quot;</span>) { textfield() }
                    field(<span class="hljs-string">&quot;Field l2a&quot;</span>) { textfield() }
                }
                vbox {
                    field(<span class="hljs-string">&quot;Field l1b&quot;</span>) { textfield() }
                    field(<span class="hljs-string">&quot;Field l2b&quot;</span>) { textfield() }
                }
            }
        }
        fieldset(<span class="hljs-string">&quot;Right FieldSet&quot;</span>) {
            hbox(<span class="hljs-number">20</span>) {
                vbox {
                    field(<span class="hljs-string">&quot;Field r1a&quot;</span>) { textfield() }
                    field(<span class="hljs-string">&quot;Field r2a&quot;</span>) { textfield() }
                }
                vbox {
                    field(<span class="hljs-string">&quot;Field r1b&quot;</span>) { textfield() }
                    field(<span class="hljs-string">&quot;Field r2b&quot;</span>) { textfield() }
                }
            }
        }
    }
}
</code></pre>
<p>The HBoxes are configured with a spacing of 20 pixels, using the parameter for the <code>hbox</code> builder. It can also be specified as <code>hbox(spacing = 20)</code> for clarity.</p>
<p><strong>Figure 7.9</strong></p>
<p><img src="https://i.imgur.com/23SwmYN.png" alt=""></p>
<h4 id="using-input-filters">Using Input Filters</h4>
<p>As a part of the <code>TextInputControl</code>, <code>filterInput</code> is a convenient way to restrict user input in form fields. <code>filterInput</code> accepts the changes to form fields and compares them against your filter. If the filter evaluates to <code>true</code>, the input is accepted. In the following example, a <code>textfield</code> has it&apos;s input restricted to integers between 0 and 10.</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> FirstTenFilter</span>: (TextFormatter.Change) -&gt; <span class="hljs-keyword">Boolean</span> = { change -&gt;
    !change.isAdded || change.controlNewText.let {
        it.isInt() &amp;&amp; it.toInt() <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>
    }
}

textfield {
    filterInput(FirstTenFilter)
}
</code></pre>
<p>The code above checks if <code>change</code> was triggered by adding new text with <code>isAdded</code> or evaluates the new text against an a function to determine if the text entered, <code>it</code>, <code>isInt()</code> and is within the range of 0-10. If any of the checks return <code>false</code>, the user input will be rejected and they will not be able to input those characters.</p>
<h3 id="gridpane">GridPane</h3>
<p>If you want to micromanage the layout of your controls, the <code>GridPane</code> will give you plenty of that. Of course it requires more configuration and code boilerplate. Before proceeding to use a <code>GridPane</code>, you might want to consider using <code>Form</code> or other layouts that abstract layout configuration for you.</p>
<p>One way to use <code>GridPane</code> is to declare the contents of each <code>row</code>. For any given <code>Node</code> you can call its <code>gridpaneConstraints</code> to configure various <code>GridPane</code> behaviors for that <code>Node</code>, such as <code>margin</code> and <code>columnSpan</code> (Figure 7.10)</p>
<pre><code class="lang-kotlin"> gridpane {
     row {
         button(<span class="hljs-string">&quot;North&quot;</span>) {
             useMaxWidth = <span class="hljs-literal">true</span>
             gridpaneConstraints {
                 marginBottom = <span class="hljs-number">10.0</span>
                 columnSpan = <span class="hljs-number">2</span>
             }
         }
     }
    row {
        button(<span class="hljs-string">&quot;West&quot;</span>)
        button(<span class="hljs-string">&quot;East&quot;</span>)
    }
    row {
        button(<span class="hljs-string">&quot;South&quot;</span>) {
            useMaxWidth = <span class="hljs-literal">true</span>
            gridpaneConstraints {
                marginTop = <span class="hljs-number">10.0</span>
                columnSpan = <span class="hljs-number">2</span>
            }
        }
    }
}
</code></pre>
<p><strong>Figure 7.11</strong></p>
<p><img src="https://i.imgur.com/zLo6aLF.png" alt=""></p>
<p>Notice how there is a margin of <code>10.0</code> between each row, which was declared for the <code>marginBottom</code> and <code>marginTop</code> of the &quot;North&quot; and &quot;South&quot; buttons respectively inside their <code>gridpaneConstraints</code>.</p>
<p>Alternatively, you can explicitly specify the column/row index positions for each <code>Node</code> rather than declaring each <code>row</code> of controls. This will accomplish the exact layout we built previously, but with column/row index specifications instead. It is a bit more verbose, but it gives you more explicit control over the positions of controls.</p>
<pre><code class="lang-kotlin">gridpane {
     button(<span class="hljs-string">&quot;North&quot;</span>) {
         useMaxWidth = <span class="hljs-literal">true</span>
         gridpaneConstraints {
             columnRowIndex(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
             marginBottom = <span class="hljs-number">10.0</span>
             columnSpan = <span class="hljs-number">2</span>
         }
     }
    button(<span class="hljs-string">&quot;West&quot;</span>).gridpaneConstraints {
        columnRowIndex(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
    }
    button(<span class="hljs-string">&quot;East&quot;</span>).gridpaneConstraints {
        columnRowIndex(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)
    }

    button(<span class="hljs-string">&quot;South&quot;</span>) {
        useMaxWidth = <span class="hljs-literal">true</span>
        gridpaneConstraints {
            columnRowIndex(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)
            marginTop = <span class="hljs-number">10.0</span>
            columnSpan = <span class="hljs-number">2</span>
        }
    }
}
</code></pre>
<p>These are all the <code>gridpaneConstraints</code> attributes you can modify on a given <code>Node</code>. Some are expressed as simple properties that can be assigned while others are assignable through functions.</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>columnIndex: Int</td>
<td>The column index for the given control</td>
</tr>
<tr>
<td>rowIndex: Int</td>
<td>The row index for the given control</td>
</tr>
<tr>
<td>columnRowIndex(columnIndex: Int, rowIndex: Int)</td>
<td>Specifes the row and column index</td>
</tr>
<tr>
<td>columnSpan: Int</td>
<td>The number of columns the control occupies</td>
</tr>
<tr>
<td>rowSpan: Int</td>
<td>The number of rows the control occupies</td>
</tr>
<tr>
<td>hGrow: Priority</td>
<td>The horizonal grow priority</td>
</tr>
<tr>
<td>vGrow: Priority</td>
<td>The vertical grow priority</td>
</tr>
<tr>
<td>vhGrow: Priority</td>
<td>Specifies the same priority for <code>vGrow</code> and <code>hGrow</code></td>
</tr>
<tr>
<td>fillHeight: Boolean</td>
<td>Sets whether the <code>Node</code> fills the height of its area</td>
</tr>
<tr>
<td>fillWidth: Boolean</td>
<td>Sets whether the <code>Node</code> filles the width of its area</td>
</tr>
<tr>
<td>fillHeightWidth: Boolean</td>
<td>Sets whether the <code>Node</code> fills its area for both height and width</td>
</tr>
<tr>
<td>hAlignment: HPos</td>
<td>The horizonal alignment policy</td>
</tr>
<tr>
<td>vAlignment: VPos</td>
<td>The vertical alignment policy</td>
</tr>
<tr>
<td>margin: Int</td>
<td>The margin for all four sides of the <code>Node</code></td>
</tr>
<tr>
<td>marginBottom: Int</td>
<td>The margin for the bottom side of the <code>Node</code></td>
</tr>
<tr>
<td>marginTop: Int</td>
<td>The margin for the top side of the <code>Node</code></td>
</tr>
<tr>
<td>marginLeft: Int</td>
<td>The left margin for the left side of the <code>Node</code></td>
</tr>
<tr>
<td>marginRight: Int</td>
<td>The right margin for the right side of the <code>Node</code></td>
</tr>
<tr>
<td>marginLeftRight: Int</td>
<td>The right and left margins for the <code>Node</code></td>
</tr>
<tr>
<td>marginTopBottom: Int</td>
<td>The top and bottom marins for a <code>Node</code></td>
</tr>
</tbody>
</table>
<p>Additionally, if you need to configure <a href="http://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/ColumnConstraints.html" target="_blank"><code>ColumnConstraints</code></a>, you can call <code>gridpaneColumnConstraints</code> on any child <code>Node</code>, or <code>constraintsForColumn(columnIndex)</code> on the <code>GridPane</code> itself.</p>
<pre><code class="lang-kotlin">gridpane {
    row {
        button(<span class="hljs-string">&quot;Left&quot;</span>) {
            gridpaneColumnConstraints {
                percentWidth = <span class="hljs-number">25.0</span>
            }
        }

        button(<span class="hljs-string">&quot;Middle&quot;</span>)
        button(<span class="hljs-string">&quot;Right&quot;</span>)
    }
    constraintsForColumn(<span class="hljs-number">1</span>).percentWidth = <span class="hljs-number">50.0</span>
}
</code></pre>
<h3 id="stackpane">StackPane</h3>
<p>A <code>StackPane</code> is a layout you will use less often. For each control you add, it will literally stack them on top of each other not like a <code>VBox</code>, but literally overlay them.</p>
<p>For instance, you can create a &quot;BOTTOM&quot; <code>Button</code> and put a &quot;TOP&quot; <code>Button</code> on top of it. The order you declare controls will add them from bottom-to-top in that same order (Figure 7.10).</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span>: <span class="hljs-type">View</span></span>() {

    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> =  stackpane {
        button(<span class="hljs-string">&quot;BOTTOM&quot;</span>) {
           useMaxHeight = <span class="hljs-literal">true</span>
           useMaxWidth = <span class="hljs-literal">true</span>
           style {
               backgroundColor += Color.AQUAMARINE
               fontSize = <span class="hljs-number">40.0</span>.px
           }
        }

        button(<span class="hljs-string">&quot;TOP&quot;</span>) {
            style {
                backgroundColor += Color.WHITE
            }
        }
    }
}
</code></pre>
<p><strong>Figure 7.11</strong></p>
<p><img src="https://i.imgur.com/2zqoxfS.png" alt=""></p>
<h3 id="tabpane">TabPane</h3>
<p>A <code>TabPane</code> creates a UI with different screens separated by &quot;tabs&quot;. This allows switching between different screens quickly and easily by clicking on the corresponding tab (Figure 7.11). You can declare a <code>tabpane()</code> and then declare as many <code>tab()</code> instances as you need. For each <code>tab()</code> function you will build your hierarchy of nodes inside, starting with the container node.</p>
<pre><code class="lang-kotlin"> tabpane {
    tab(<span class="hljs-string">&quot;Screen 1&quot;</span>) {
        vbox {
            button(<span class="hljs-string">&quot;Button 1&quot;</span>)
            button(<span class="hljs-string">&quot;Button 2&quot;</span>)
        }
    }
    tab(<span class="hljs-string">&quot;Screen 2&quot;</span>) {
        hbox {
            button(<span class="hljs-string">&quot;Button 3&quot;</span>)
            button(<span class="hljs-string">&quot;Button 4&quot;</span>)
        }
    }
}
</code></pre>
<p><strong>Figure 7.12</strong></p>
<p><img src="https://i.imgur.com/ZvnfdgP.png" alt=""><img src="https://i.imgur.com/LvpYymO.png" alt=""></p>
<p><code>TabPane</code> is an effective tool to separate screens and organize a high number of controls. The syntax is somewhat succinct enough to declare complex controls like <code>TableView</code> right inside the <code>tab()</code> block (Figure 7.13).</p>
<pre><code class="lang-kotlin">tabpane {
  tab(<span class="hljs-string">&quot;Screen 1&quot;</span>) {
      vbox {
          button(<span class="hljs-string">&quot;Button 1&quot;</span>)
          button(<span class="hljs-string">&quot;Button 2&quot;</span>)
      }
  }
  tab(<span class="hljs-string">&quot;Screen 2&quot;</span>) {
      tableview<span class="hljs-type">&lt;Person&gt;</span> {
          items = listOf(
              Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Samantha Stuart&quot;</span>,LocalDate.of(<span class="hljs-number">1981</span>,<span class="hljs-number">12</span>,<span class="hljs-number">4</span>)),
              Person(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Tom Marks&quot;</span>,LocalDate.of(<span class="hljs-number">2001</span>,<span class="hljs-number">1</span>,<span class="hljs-number">23</span>)),
              Person(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Stuart Gills&quot;</span>,LocalDate.of(<span class="hljs-number">1989</span>,<span class="hljs-number">5</span>,<span class="hljs-number">23</span>)),
              Person(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Nicole Williams&quot;</span>,LocalDate.of(<span class="hljs-number">1998</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>))
          ).observable()

          column(<span class="hljs-string">&quot;ID&quot;</span>,Person::id)
          column(<span class="hljs-string">&quot;Name&quot;</span>, Person::name)
          column(<span class="hljs-string">&quot;Birthday&quot;</span>, Person::birthday)
          column(<span class="hljs-string">&quot;Age&quot;</span>,Person::age)
      }
  }
}
</code></pre>
<p><strong>Figure 7.13</strong></p>
<p><img src="https://i.imgur.com/61qYOW2.png" alt=""></p>
<p>Like many builders, the <code>TabPane</code> has several properties that can adjust the behavior of its tabs. For instance, you can call <code>tabClosingPolicy</code> to get rid of the &quot;X&quot; buttons on the tabs so they cannot be closed.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span>: <span class="hljs-type">View</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> =  tabpane {
        tabClosingPolicy = TabPane.TabClosingPolicy.UNAVAILABLE

        tab(<span class="hljs-string">&quot;Screen 1&quot;</span>) {
            vbox {
                button(<span class="hljs-string">&quot;Button 1&quot;</span>)
                button(<span class="hljs-string">&quot;Button 2&quot;</span>)
            }
        }
        tab(<span class="hljs-string">&quot;Screen 2&quot;</span>) {
            hbox {
                button(<span class="hljs-string">&quot;Button 3&quot;</span>)
                button(<span class="hljs-string">&quot;Button 4&quot;</span>)
            }
        }
    }
}
</code></pre>
<h3 id="using-uicomponents-as-tabs">Using UIComponents as tabs</h3>
<p>You can also embed other UIComponents like Fragments and Views in your Tabs, simply by adding them with either the generic <code>add</code> function or the specialized <code>tab</code> function:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> : <span class="hljs-type">View</span></span>(<span class="hljs-string">&quot;My TabPane&quot;</span>) {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = tabpane {
        tab<span class="hljs-type">&lt;Screen1&gt;</span>()
        tab<span class="hljs-type">&lt;Screen2&gt;</span>()
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen1</span> : <span class="hljs-type">Fragment</span></span>(<span class="hljs-string">&quot;Screen 1&quot;</span>) {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = vbox {
        button(<span class="hljs-string">&quot;Button 1&quot;</span>)
        button(<span class="hljs-string">&quot;Button 2&quot;</span>)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen2</span> : <span class="hljs-type">Fragment</span></span>(<span class="hljs-string">&quot;Screen 2&quot;</span>) {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = vbox {
        button(<span class="hljs-string">&quot;Button 3&quot;</span>)
        button(<span class="hljs-string">&quot;Button 4&quot;</span>)
    }
}
</code></pre>
<p>This strategy promotes reuse and keeps your UI code cleaner.</p>
<h2 id="builders-for-menus">Builders for Menus</h2>
<p>Creating menus can be cumbersome to build in a strictly object-oriented way. But using type-safe builders, Kotlin&apos;s functional constructs make it intuitive to declare nested menu hierarchies.</p>
<h3 id="menubar-menu-and-menuitem">MenuBar, Menu, and MenuItem</h3>
<p>It is not uncommon to use navigable menus to keep a large number of commands on a user interface organized. For instance, the <code>top</code> region of a <code>BorderPane</code> is typically where a <code>MenuBar</code> goes. There you can add menus and submenus easily (Figure 7.5).</p>
<pre><code class="lang-kotlin">menubar {
   menu(<span class="hljs-string">&quot;File&quot;</span>) {
       menu(<span class="hljs-string">&quot;Connect&quot;</span>) {
           item(<span class="hljs-string">&quot;Facebook&quot;</span>)
           item(<span class="hljs-string">&quot;Twitter&quot;</span>)
       }
       item(<span class="hljs-string">&quot;Save&quot;</span>)
       item(<span class="hljs-string">&quot;Quit&quot;</span>)
   }
   menu(<span class="hljs-string">&quot;Edit&quot;</span>) {
       item(<span class="hljs-string">&quot;Copy&quot;</span>)
       item(<span class="hljs-string">&quot;Paste&quot;</span>)
   }
}
</code></pre>
<p><strong>Figure 7.14</strong></p>
<p><img src="https://i.imgur.com/6BfumlL.png" alt=""></p>
<p>You can also optionally provide keyboard shortcuts, graphics, as well as an <code>action</code> function parameter for each <code>item()</code> to specify the action when it is selected (Figure 7.14).</p>
<pre><code class="lang-kotlin">menubar {
     menu(<span class="hljs-string">&quot;File&quot;</span>) {
         menu(<span class="hljs-string">&quot;Connect&quot;</span>) {
             item(<span class="hljs-string">&quot;Facebook&quot;</span>, graphic = fbIcon).action { println(<span class="hljs-string">&quot;Connecting Facebook!&quot;</span>) }
             item(<span class="hljs-string">&quot;Twitter&quot;</span>, graphic = twIcon).action { println(<span class="hljs-string">&quot;Connecting Twitter!&quot;</span>) }
         }
         item(<span class="hljs-string">&quot;Save&quot;</span>,<span class="hljs-string">&quot;Shortcut+S&quot;</span>).action {
             println(<span class="hljs-string">&quot;Saving!&quot;</span>)
         }
         item(<span class="hljs-string">&quot;Quit&quot;</span>,<span class="hljs-string">&quot;Shortcut+Q&quot;</span>).action {
             println(<span class="hljs-string">&quot;Quitting!&quot;</span>)
         }
     }
     menu(<span class="hljs-string">&quot;Edit&quot;</span>) {
         item(<span class="hljs-string">&quot;Copy&quot;</span>,<span class="hljs-string">&quot;Shortcut+C&quot;</span>).action {
             println(<span class="hljs-string">&quot;Copying!&quot;</span>)
         }
         item(<span class="hljs-string">&quot;Paste&quot;</span>,<span class="hljs-string">&quot;Shortcut+V&quot;</span>).action {
             println(<span class="hljs-string">&quot;Pasting!&quot;</span>)
         }
     }
 }
</code></pre>
<p><strong>Figure 7.14</strong></p>
<p><img src="https://i.imgur.com/q18nOAx.png" alt=""></p>
<h4 id="separators">Separators</h4>
<p>You can declare a <code>separator()</code> between two items in a <code>Menu</code> to create a divider line. This is helpful to group commands in a <code>Menu</code> and distinctly separate them (Figure 7.15).</p>
<pre><code class="lang-kotlin"> menu(<span class="hljs-string">&quot;File&quot;</span>) {
     menu(<span class="hljs-string">&quot;Connect&quot;</span>) {
         item(<span class="hljs-string">&quot;Facebook&quot;</span>)
         item(<span class="hljs-string">&quot;Twitter&quot;</span>)
     }
     separator()
     item(<span class="hljs-string">&quot;Save&quot;</span>,<span class="hljs-string">&quot;Shortcut+S&quot;</span>).action {
         println(<span class="hljs-string">&quot;Saving!&quot;</span>)
     }
     item(<span class="hljs-string">&quot;Quit&quot;</span>,<span class="hljs-string">&quot;Shortcut+Q&quot;</span>).action {
         println(<span class="hljs-string">&quot;Quitting!&quot;</span>)
     }
 }
</code></pre>
<p><strong>Figure 7.15</strong></p>
<p><img src="https://i.imgur.com/JIc4Xce.png" alt=""></p>
<h4 id="contextmenu">ContextMenu</h4>
<p>Most controls in JavaFX have a <code>contextMenu</code> property where you can assign a <code>ContextMenu</code> instance. This is a <code>Menu</code> that pops up when the control is right-clicked.</p>
<p>A <code>ContextMenu</code> has functions to add <code>Menu</code> and <code>MenuItem</code> instances to it just like a <code>MenuBar</code>. It can be helpful to add a <code>ContextMenu</code> to a <code>TableView&lt;Person&gt;</code>, for example, and provide commands to be done on a table record (Figure 7.16). There is
a builder called <code>contextmenu</code> that will build a <code>ContextMenu</code> and assign it to the <code>contextMenu</code> property of the control.</p>
<pre><code class="lang-kotlin">tableview(persons) {
     column(<span class="hljs-string">&quot;ID&quot;</span>, Person::idProperty)
     column(<span class="hljs-string">&quot;Name&quot;</span>, Person::nameProperty)
     column(<span class="hljs-string">&quot;Birthday&quot;</span>, Person::birthdayProperty)
     column(<span class="hljs-string">&quot;Age&quot;</span>, Person::ageProperty)

     contextmenu {
         item(<span class="hljs-string">&quot;Send Email&quot;</span>).action {
             selectedItem?.apply { println(<span class="hljs-string">&quot;Sending Email to $name&quot;</span>) }
         }
         item(<span class="hljs-string">&quot;Change Status&quot;</span>).action {
             selectedItem?.apply { println(<span class="hljs-string">&quot;Changing Status for $name&quot;</span>) }
         }
     }
 }
</code></pre>
<p> <strong>Figure 7.16</strong></p>
<p> <img src="https://i.imgur.com/AYvIuOU.png" alt=""></p>
<blockquote>
<p>Note there are also <code>RadioMenuItem</code> and <code>CheckMenuItem</code> variants of <code>MenuItem</code> available.</p>
</blockquote>
<p>The <code>menuitem</code> builders take the action to perform when the menu is selected as the op block parameter. Unfortunately, this breaks with the other builders, where the op block operates on the 
element that the builder created. Therefore, the <code>item</code> builder was introduced as an alternative, where you operate on the item itself, so that you must call <code>setOnAction</code> to assign the action.
The <code>menuitem</code> builder is not deprecated, as it solves the common case in a more concise way than the <code>item</code> builder.</p>
<h2 id="listmenu">ListMenu</h2>
<p>TornadoFX comes with a list menu that behaves and looks more like a typical <code>ul/li</code> based HTML5 menu.</p>
<p><img src="https://i.imgur.com/Utq63HV.gif" alt=""></p>
<p>The following code example shows how to use the <code>ListMenu</code> with the builder pattern:</p>
<pre><code class="lang-kotlin">listmenu(theme = <span class="hljs-string">&quot;blue&quot;</span>) {
    item(text = <span class="hljs-string">&quot;Contacts&quot;</span>, graphic = Styles.contactsIcon()) {
        <span class="hljs-comment">// Marks this item as active.</span>
        activeItem = this
        whenSelected { <span class="hljs-comment">/* Do some action */</span> }
    }
    item(text = <span class="hljs-string">&quot;Projects&quot;</span>, graphic = Styles.projectsIcon())
    item(text = <span class="hljs-string">&quot;Settings&quot;</span>, graphic = Styles.settingsIcon())
}
</code></pre>
<p>The following Attributes can be used to configure the <code>ListMenu</code>:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Builder-Attribute</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>orientation</td>
<td>yes</td>
<td>Orientation</td>
<td>VERTICAL</td>
<td>Configures the orientation of the <code>ListMenu</code>. Possible orientations:  <ul><li>VERTICAL</li><li>HORIZONTAL</li></ul></td>
</tr>
<tr>
<td>iconPosition</td>
<td>yes</td>
<td>Side</td>
<td>LEFT</td>
<td>Configures the icon position of the <code>ListMenu</code>. Possible positions: <ul><li>TOP</li><li>BOTTOM</li><li>LEFT</li><li>RIGHT</li></ul></td>
</tr>
<tr>
<td>theme</td>
<td>yes</td>
<td>String</td>
<td>null</td>
<td>Currently supported themes <code>blue</code>, <code>null</code>. If <code>null</code> is set the default gray theme is used.</td>
</tr>
<tr>
<td>tag</td>
<td>yes</td>
<td>Any?</td>
<td>null</td>
<td>The Tag can be any <code>object</code> or <code>null</code>, it can be useful to identify the <code>ListMenu</code></td>
</tr>
<tr>
<td>activeItem</td>
<td>no</td>
<td>ListMenuItem?</td>
<td>null</td>
<td>Represent&apos;s the current active <code>ListMenuItem</code> of the <code>ListMenu</code>. To select a <code>ListMenu</code> on creation, just assign the specific <code>ListItem</code> to this property (have a look at the contacts <code>ListMenuItem</code> in the code example above.)</td>
</tr>
</tbody>
</table>
<h2 id="css-properties">Css Properties</h2>
<table>
<thead>
<tr>
<th>Css-Class</th>
<th>Css-Property</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.list-menu</code></td>
<td>-fx-graphic-fixed-size</td>
<td>2em</td>
<td>The graphic size.</td>
</tr>
<tr>
<td><code>.list-menu .list-item</code></td>
<td>-fx-cursor</td>
<td>hand</td>
<td>The cursor symbol.</td>
</tr>
<tr>
<td><code>.list-menu .list-item</code></td>
<td>-fx-padding</td>
<td>10</td>
<td>The padding for each <code>item</code></td>
</tr>
<tr>
<td><code>.list-menu .list-item</code></td>
<td>-fx-background-color</td>
<td>-fx-shadow-highlight-color, -fx-outer-border, -fx-inner-border, -fx-body-color</td>
<td>The color of the <code>item</code></td>
</tr>
<tr>
<td><code>.list-menu .list-item</code></td>
<td>-fx-background-insets</td>
<td>0 0 -0.5 0, 0, 0.5, 1.5</td>
<td>The insets of each <code>item</code>.</td>
</tr>
<tr>
<td><code>.list-menu .list-item .label</code></td>
<td>-fx-text-fill</td>
<td>-fx-text-base-color</td>
<td>The text color of each <code>item</code>.</td>
</tr>
</tbody>
</table>
<h2 id="pseudo-classes">Pseudo Classes</h2>
<table>
<thead>
<tr>
<th>Pseudo-Class</th>
<th>Css-Property</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.list-menu .list-item:active</code></td>
<td>-fx-background-color</td>
<td>-fx-focus-color, -fx-inner-border, -fx-body-color, -fx-faint-focus-color, -fx-body-color</td>
<td>The color will be set if the <code>item</code> is active.</td>
</tr>
<tr>
<td><code>.list-menu .list-item:active</code></td>
<td>-fx-background-insets</td>
<td>-0.2, 1, 2, -1.4, 2.6</td>
<td>Insets will be set if the <code>item</code> is active.</td>
</tr>
<tr>
<td><code>.list-menu .list-item:hover</code></td>
<td>-fx-color</td>
<td>-fx-hover-base</td>
<td>The hover color.</td>
</tr>
</tbody>
</table>
<p>Have a look at the default Stylesheet for the <a href="https://github.com/edvin/tornadofx/blob/master/src/main/resources/tornadofx/listmenu.css" target="_blank">ListMenu</a></p>
<h3 id="item">Item</h3>
<p>The <code>item</code> builder allows to create <code>items</code> for the <code>ListMenu</code> in a very convenient way. The following syntax is supported:</p>
<pre><code class="lang-kotlin">item(<span class="hljs-string">&quot;SomeText&quot;</span>, graphic = SomeNode, tag = SomeObject) {
    <span class="hljs-comment">// Marks this item as active.</span>
    activeItem = this

    <span class="hljs-comment">// Do some action when selected</span>
    whenSelected { <span class="hljs-comment">/* Action */</span> }
}
</code></pre>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Builder-Attribute</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td>yes</td>
<td>String?</td>
<td>null</td>
<td>The text which should be set for the given <code>item</code>.</td>
</tr>
<tr>
<td>tag</td>
<td>yes</td>
<td>Any?</td>
<td>null</td>
<td>The Tag can be any <code>object</code> or <code>null</code> and can be useful to identify the <code>ListItem</code></td>
</tr>
<tr>
<td>graphic</td>
<td>yes</td>
<td>Node?</td>
<td>null</td>
<td>The <code>graphic</code> can be any <code>Node</code> and will be displayed beside the given <code>text</code>.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>whenSelected</code></td>
<td>A convince function, which will be called anytime the given <code>ListMenuItem</code> is selected.</td>
</tr>
</tbody>
</table>
<h3 id="filling-the-parent-container">Filling the parent container</h3>
<p>The <code>useMaxWidth</code> property can be used to fill the parent container horizontally. The <code>useMaxHeight</code> property will fill the parent container vertically. These properties
actually applies to all Nodes, but is especially useful for the <code>ListMenu</code>.</p>
<h2 id="squeezebox">SqueezeBox</h2>
<p>JavaFX has an Accordion control that lets you group a set of <code>TilePanes</code> together to form an accordion of controls. The JavaFX Accordion only lets you open a single accordion fold at a time, and it has
some other shortcomings. To solve this, TornadoFX comes with the <code>SqueezeBox</code> component that behaves and looks very similar to the Accordion, while providing some enhancements.</p>
<pre><code class="lang-kotlin">squeezebox {
    fold(<span class="hljs-string">&quot;Customer Editor&quot;</span>, expanded = <span class="hljs-literal">true</span>) {
        form {
            fieldset(<span class="hljs-string">&quot;Customer Details&quot;</span>) {
                field(<span class="hljs-string">&quot;Name&quot;</span>) { textfield() }
                field(<span class="hljs-string">&quot;Password&quot;</span>) { textfield() }
            }
        }
    }
    fold(<span class="hljs-string">&quot;Some other editor&quot;</span>, expanded = <span class="hljs-literal">true</span>) {
        stackpane {
            label(<span class="hljs-string">&quot;Nothing here&quot;</span>)
        }
    }
}
</code></pre>
<p><strong>Figure 7.17</strong></p>
<p><img src="https://i.imgur.com/eQ2WT6N.png" alt=""></p>
<blockquote>
<p>A Squeezebox showing two folds, both expanded by default</p>
</blockquote>
<p>You can tell the SqueezeBox to only allow a single fold to be expanded at any given time by passing <code>multiselect = false</code> to the builder constructor.</p>
<p>You can optionally allow folds to be closable by clicking a cross in the right corner of the title pane for the fold. You enable the close buttons on a per fold
 basis by passing <code>closeable = true</code> to the <code>fold</code> builder.</p>
<pre><code class="lang-kotlin">squeezebox {
    fold(<span class="hljs-string">&quot;Customer Editor&quot;</span>, expanded = <span class="hljs-literal">true</span>, closeable = <span class="hljs-literal">true</span>) {
        form {
            fieldset(<span class="hljs-string">&quot;Customer Details&quot;</span>) {
                field(<span class="hljs-string">&quot;Name&quot;</span>) { textfield() }
                field(<span class="hljs-string">&quot;Password&quot;</span>) { textfield() }
            }
        }
    }
    fold(<span class="hljs-string">&quot;Some other editor&quot;</span>, closeable = <span class="hljs-literal">true</span>) {
        stackpane {
            label(<span class="hljs-string">&quot;Nothing here&quot;</span>)
        }
    }
}
</code></pre>
<p><strong>Figure 7.18</strong></p>
<p><img src="https://i.imgur.com/hAbnrwQ.png" alt=""></p>
<blockquote>
<p>This SqueezeBox has closeable folds</p>
</blockquote>
<p>The <code>closeable</code> property can of course be combined with <code>expanded</code>.</p>
<p>Another important difference between the SqueezeBox and the Accordion is the way it distributes overflowing space. The Accordion will extend vertically to fill its parent container
and push any folds below the currently opened ones all the way to the bottom. This creates an unnatural looking view if the parent container is very large. The squeezebox
probably does what you want by default in this regard, but you can add <code>fillHeight = true</code> to get a similar look as the Accordion.I</p>
<p>You can style the SqueezeBox like you style a TitlePane. The close button has a css class called <code>close-button</code> and the container has a css class called <code>squeeze-box</code>.</p>
<h2 id="drawer">Drawer</h2>
<p>The Drawer is a navigation component much like a TabPane, but it organizes each drawer item in a vertically or horizontally placed button bar on either side of the parent container. It resembles
the tool drawers found in many popular business applications and IDEs. When an item is selected, the content for the item is displayed next to or above/below the buttons in a content area spanning the height or width
of the control and the preferred width or height of the content, depending on whether it is docked in a vertical or horizontal side of the parent. In <code>multiselect</code> mode it will even let you open multiple drawer items simutaneously and have them share the space between them.
They will always open in the order of the corresponding buttons.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawerView</span> : <span class="hljs-type">View</span></span>(<span class="hljs-string">&quot;TornadoFX Info Browser&quot;</span>) {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = drawer {
        item(<span class="hljs-string">&quot;Screencasts&quot;</span>, expanded = <span class="hljs-literal">true</span>) {
            webview {
                prefWidth = <span class="hljs-number">470.0</span>
                engine.userAgent = iPhoneUserAgent
                engine.load(TornadoFXScreencastsURI)
            }
        }
        item(<span class="hljs-string">&quot;Links&quot;</span>) {
            listview(links) {
                cellFormat { link -&gt;
                    graphic = hyperlink(link.name) {
                        setOnAction {
                            hostServices.showDocument(link.uri)
                        }
                    }
                }
            }
        }
        item(<span class="hljs-string">&quot;People&quot;</span>) {
            tableview(people) {
                column(<span class="hljs-string">&quot;Name&quot;</span>, Person::name)
                column(<span class="hljs-string">&quot;Nick&quot;</span>, Person::nick)
            }
        }
   }

   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Link</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String, <span class="hljs-variable"><span class="hljs-keyword">val</span> uri</span>: String)
   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String, <span class="hljs-variable"><span class="hljs-keyword">val</span> nick</span>: String)

   <span class="hljs-comment">// Sample data variables left out (iPhoneUserAgent, TornadoFXScreencastsURI, people and links)</span>
}
</code></pre>
<p><strong>Figure 7.19</strong></p>
<p><img src="https://i.imgur.com/cJp4SGo.png" alt=""></p>
<p>The drawer can be configured to show the buttons on the right side, and you can choose to support opening multiple drawer
items simultaneously. When running in multiselect mode, a header will appear above the content, which will help to
distinguish the items in the content area. You can control the header appearance with the boolean <code>showHeader</code> parameter.
It will default true when multiselect is enabled and false otherwise.</p>
<pre><code class="lang-kotlin">drawer(side = Side.RIGHT, multiselect = <span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// Everything else is identical</span>
}
</code></pre>
<p><strong>Figure 7.20</strong></p>
<p><img src="https://i.imgur.com/q4jN9Cc.png" alt=""></p>
<blockquote>
<p>Drawer with buttons on the right side, multiselect mode and title panes</p>
</blockquote>
<p>When the Drawer is added next to something, you can choose whether the content area of the Drawer should displace the
nodes next to it (default) or float over it. The <code>floatingContent</code> property is by default false, causing the Drawer to 
displace the content next to it.</p>
<p>You can control the size of the content area further using the <code>maxContentSize</code> and <code>fixedContentSize</code> properties of <code>Drawer</code>.
Depending on the <code>dockingSide</code>, those properties will constrain either the width or the height of the content area.</p>
<p>The <code>Workspace</code> features built in support for the Drawer control. The <code>leftDrawer</code>, <code>rightDrawer</code> and <code>bottomDrawer</code> properties of any Workspace will let you dock drawer items into them. Read more about this
in the Workspace chapter.</p>
<h2 id="converting-observable-list-items-and-binding-to-layouts">Converting observable list items and binding to layouts</h2>
<p>TODO</p>
<h2 id="summary">Summary</h2>
<p>By now you should have the tools to quickly create complex UI&apos;s with layouts, tabbed panes, as well as other controls to manage controls. Using these in conjunction with the data controls, you should be able to turn around UI&apos;s in a fraction of the time.</p>
<p>When it comes to builders, you have reached the top of the peak and have everything you need to be productive. All that is left to cover are charts and shapes, which we will cover in the next two chapters.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="6. CSS.html" class="navigation navigation-prev " aria-label="Previous page: 6. Type Safe CSS">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="8. Charts.html" class="navigation navigation-next " aria-label="Next page: 8. Charts">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"7. Layouts and Menus","level":"1.2.7","depth":2,"next":{"title":"8. Charts","level":"1.2.8","depth":2,"path":"part1/8. Charts.md","ref":"part1/8. Charts.md","articles":[]},"previous":{"title":"6. Type Safe CSS","level":"1.2.6","depth":2,"path":"part1/6. CSS.md","ref":"part1/6. CSS.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"part1/7. Layouts and Menus.md","mtime":"2020-02-13T15:46:37.950Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-02-13T15:47:39.413Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

