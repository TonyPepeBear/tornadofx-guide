# 基本介紹

使用者介面對於消費者和商務應用變得越來越重要，伴隨者行動和網頁應用程式成長，商務上對於對於應用程式的基本的品質有了更高的要求，他們需要功能更加豐富的使用者介面，並且提供更直觀的瀏覽體驗在複雜的螢幕上。更重要的是，他們希望應用程式能更快的跟上商務變化。對於開發者，這代表應用程式不應該只是可維護的，更要是可進化的。TornadoFX 就是在尋求這些目標，和大大的簡化 JavaFX UI 的開發。

雖然大部分的企業都在推行 HTML5 和雲端應用程式，但是許多企業都還是在使用像是 JavaFX 的桌面型 UI。雖然不像是雲端應用程式那麼容易發布給大眾，但是 JavaFX 還是很適用於內部的商業應用。他對於大型的 datasets 有很高的效能，使他成為企業內部防火牆後很好的選擇。

JavaFx 跟許多的 UI 框架一樣，容易就變得非常複雜且難以維護。幸運的是，迅速成長的 Kotlin 有機會讓構建一個 JavaFX 的應用程式被重新考慮。

# 為什麼選擇 TornadoFX?

在 2016 年的二月，JetBrains 發布了 [Kotlin](http://kotlinlang.org) ，一個在 JVM 平台上的新語言，強調實用而非慣例。Kotlin 在更高的抽象層級工作，而且提供許多 Java 沒有提供的語法特性。更重要的 Kotlin 語法特性就是 100% 的與 Java 現有的函式庫的互通通用，當然也包括 JavaFX。最重要的是，Google 在 2017 年時，宣布支持 Kotlin 成為 Android 的官方語言，這給了 Kotlin 擴展到手機應用程式一個光明的未來。

雖然 JavaFX 一樣可以使用 Kotlin 以 Java 的方式編寫，但是 Kotlin 的語言特性可以讓開發 JavaFX 可以更精簡和簡單。在 Kotlin 的 beta 版本發布前，Eugen Kiss 就開始用 KotlinFX 原型化 JavaFX 的構建器，在 2016 年一月，Eugen Kiss 重新開始了計畫，並且發布了 TornadoFX。

TornadoFX 尋求減少開發 JavaFX 的程式碼的數量，不僅包含了型別安全 (type-safe)的建構器來產生控制介面和用戶介面，還包含了依賴注入 (dependency injection)、委託屬性 (delegated properties)、控制擴展功能 (control extension functions)，及其他 Kotlin 的特性。TornadoFX 是一個展示 Kotlin 如何在開發 UI 時簡化程式碼和解決程式碼冗長的問題。他還可以結合其他受歡迎的 JavaFX 函式庫，像是 [ControlsFX](http://fxexperience.com/controlsfx/) 和 [JFXtras](http://jfxtras.org/)。而且可以與 [ReactFX](https://github.com/TomasMikula/ReactFX)、[RxJava](https://github.com/ReactiveX/RxJava)、[RxKotlin](https://github.com/ReactiveX/RxKotlin)、[RxKotlinFX](https://github.com/thomasnield/RxKotlinFX) 都有很好的配合。

# Reader Requirements

This book expects readers to have some knowledge of Kotlin and have spent some time getting acquainted with it. There will be some coverage of Kotlin language features but only to a certain extent. If you have not done so already, read the [JetBrains Kotlin Reference](https://kotlinlang.org/docs/reference/) and spend a good few hours studying it.

It helps to be familiar with JavaFX but it is not a requirement. Many Kotlin developers reported using TornadoFX successfully without any JavaFX knowledge. What is particularly important to know about JavaFX is its concepts of `ObservableValue` and `Bindings`, which this guide will cover to a good degree. 

# A Motivational Example

If you have worked with JavaFX before, you might have created a `TableView` at some point. Say you have a given domain type `Person`. TornadoFX allows you to much more concisely create the JavaBeans-like convention used for the JavaFX binding.

```kotlin
class Person(id: Int, name: String, birthday: LocalDate) {
    val idProperty = SimpleIntegerProperty(id)
    var id by idProperty

    val nameProperty = SimpleStringProperty(name)
    var name by nameProperty

    val birthdayProperty = SimpleObjectProperty(birthday)
    var birthday by birthdayProperty

    val age: Int get() = Period.between(birthday, LocalDate.now()).years
}
```

You can then build an entire "`View`" containing a `TableView` with a small code footprint.

```kotlin
class MyView : View() {

    private val persons = listOf(
            Person(1, "Samantha Stuart", LocalDate.of(1981,12,4)),
            Person(2, "Tom Marks", LocalDate.of(2001,1,23)),
            Person(3, "Stuart Gills", LocalDate.of(1989,5,23)),
            Person(4, "Nicole Williams", LocalDate.of(1998,8,11))
    ).observable()

    override val root = tableview(persons) {
        column("ID", Person::idProperty)
        column("Name", Person::nameProperty)
        column("Birthday", Person::birthdayProperty)
        readonlyColumn("Age", Person::age)
    }
}
```

**RENDERED OUTPUT:**

![](https://camo.githubusercontent.com/21d91e000f36556b67bea322ff1152199aee483e/68747470733a2f2f692e696d6775722e636f6d2f41474d435038532e706e67)

Half of that code was just initializing sample data! If you hone in on just the part declaring the `TableView` with four columns (shown below), you will see it took a simple functional construct to build a `TableView`. It will automatically support edits to the fields as well.

```kotlin
tableview(persons) {
    column("ID", Person::idProperty)
    column("Name", Person::nameProperty)
    column("Birthday", Person::birthdayProperty)
    readonlyColumn("Age", Person::age)
}
```

As shown below, we can use the `cellFormat()` extension function on a `TableColumn`, and create conditional formatting for "Age" values that are less than `18`.

```kotlin
tableview<Person> {
    items = persons
    column("ID", Person::idProperty)
    column("Name", Person::nameProperty)
    column("Birthday", Person::birthdayProperty)
    readonlyColumn("Age", Person::age).cellFormat {
        text = it.toString()
        style {
            if (it < 18) {
                backgroundColor += c("#8b0000")
                textFill = Color.WHITE
            }
        }
    }
}
```

**RENDERED OUTPUT:**

![](https://camo.githubusercontent.com/dbc9a172be484e4ab8eeb0accc3799500e9fe791/68747470733a2f2f692e696d6775722e636f6d2f4d7932475545762e706e67)

These declarations are pure Kotlin code, and TornadoFX is packed with expressive power for dozens of cases like this. This allows you to focus on creating solutions rather than engineering UI code. Your JavaFX applications will not only be turned around more quickly, but also be maintainable and evolvable.
