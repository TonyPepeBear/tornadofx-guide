
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>5. Data Controls · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="6. CSS.html" />
    
    
    <link rel="prev" href="4. Basic Controls.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="0. Subsection.html">
            
                <a href="0. Subsection.html">
            
                    
                    第一部分: TornadoFX 基本介紹
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="1. Why TornadoFX.html">
            
                <a href="1. Why TornadoFX.html">
            
                    
                    1. 為什麼選擇 TornadoFX?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="2. Setting Up.html">
            
                <a href="2. Setting Up.html">
            
                    
                    2. 配置
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="3. Components.html">
            
                <a href="3. Components.html">
            
                    
                    3. 組件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="4. Basic Controls.html">
            
                <a href="4. Basic Controls.html">
            
                    
                    4. Basic Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.5" data-path="5. Data Controls.html">
            
                <a href="5. Data Controls.html">
            
                    
                    5. Data Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="6. CSS.html">
            
                <a href="6. CSS.html">
            
                    
                    6. Type Safe CSS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="7. Layouts and Menus.html">
            
                <a href="7. Layouts and Menus.html">
            
                    
                    7. Layouts and Menus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="8. Charts.html">
            
                <a href="8. Charts.html">
            
                    
                    8. Charts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="9. Shapes and Animation.html">
            
                <a href="9. Shapes and Animation.html">
            
                    
                    9. Shapes and Animation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="10. FXML.html">
            
                <a href="10. FXML.html">
            
                    
                    10. FXML
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="11. Editing Models and Validation.html">
            
                <a href="11. Editing Models and Validation.html">
            
                    
                    11. Editing Models and Validation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="12. TornadoFX IDEA Plugin.html">
            
                <a href="12. TornadoFX IDEA Plugin.html">
            
                    
                    12. TornadoFX IDEA Plugin
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../part2/0. Subsection.html">
            
                <a href="../part2/0. Subsection.html">
            
                    
                    Part 2: TornadoFX Advanced Features
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../part2/Property Delegates.html">
            
                <a href="../part2/Property Delegates.html">
            
                    
                    Property Delegates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../part2/Advanced Data Controls.html">
            
                <a href="../part2/Advanced Data Controls.html">
            
                    
                    Advanced Data Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../part2/OSGi.html">
            
                <a href="../part2/OSGi.html">
            
                    
                    OSGi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../part2/Scopes.html">
            
                <a href="../part2/Scopes.html">
            
                    
                    Scopes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../part2/EventBus.html">
            
                <a href="../part2/EventBus.html">
            
                    
                    EventBus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../part2/Workspaces.html">
            
                <a href="../part2/Workspaces.html">
            
                    
                    Workspaces
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../part2/Layout Debugger.html">
            
                <a href="../part2/Layout Debugger.html">
            
                    
                    Layout Debugger
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../part2/Internationalization.html">
            
                <a href="../part2/Internationalization.html">
            
                    
                    Internationalization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../part2/Config Settings and State.html">
            
                <a href="../part2/Config Settings and State.html">
            
                    
                    Config Settings and State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="../part2/JSON and REST.html">
            
                <a href="../part2/JSON and REST.html">
            
                    
                    JSON and REST
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="../part2/Dependency Injection.html">
            
                <a href="../part2/Dependency Injection.html">
            
                    
                    Dependency Injection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="../part2/Wizard.html">
            
                <a href="../part2/Wizard.html">
            
                    
                    Wizard
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="../part2/Integration.html">
            
                <a href="../part2/Integration.html">
            
                    
                    Integrating with other tech
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../part3/0. Subsection.html">
            
                <a href="../part3/0. Subsection.html">
            
                    
                    Part 3: Cook Book
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../part3/Snippets.html">
            
                <a href="../part3/Snippets.html">
            
                    
                    Snippets
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >5. Data Controls</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="data-controls">Data Controls</h1>
<p>Any significant application works with data, and providing a means for users to view, manipulate, and modify data is not a trivial task for user interface development. Fortunately, TornadoFX streamlines many JavaFX data controls such as <code>ListView</code>, <code>TableView</code>, <code>TreeView</code>, and <code>TreeTableView</code>. These controls can be cumbersome to set up in a purely object-oriented way. But using builders through functional declarations, we can code all these controls in a much more streamlined way.</p>
<h3 id="listview">ListView</h3>
<p>A <code>ListView</code> is similar to a <code>ComboBox</code> but it displays all items within a <code>ScrollView</code> and has the option of allowing multiple selections, as shown in Figure 5.1</p>
<pre><code class="lang-kotlin">listview<span class="hljs-type">&lt;String&gt;</span> {
    items.add(<span class="hljs-string">&quot;Alpha&quot;</span>)
    items.add(<span class="hljs-string">&quot;Beta&quot;</span>)
    items.add(<span class="hljs-string">&quot;Gamma&quot;</span>)
    items.add(<span class="hljs-string">&quot;Delta&quot;</span>)
    items.add(<span class="hljs-string">&quot;Epsilon&quot;</span>)
    selectionModel.selectionMode = SelectionMode.MULTIPLE
}
</code></pre>
<p><strong>Figure 5.1</strong></p>
<p><img src="https://i.imgur.com/D78DGbD.png" alt=""></p>
<p>You can also provide it an <code>ObservableList</code> of items up front and omit the type declaration since it can be inferred. Using an <code>ObservableList</code> has the benefit that changes to the list will automatically be reflected in the <code>ListView</code>.</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> greekLetters</span> = listOf(<span class="hljs-string">&quot;Alpha&quot;</span>,<span class="hljs-string">&quot;Beta&quot;</span>,
        <span class="hljs-string">&quot;Gamma&quot;</span>,<span class="hljs-string">&quot;Delta&quot;</span>,<span class="hljs-string">&quot;Epsilon&quot;</span>).asObservable()

listview(greekLetters) {
    selectionModel.selectionMode = SelectionMode.MULTIPLE
}
</code></pre>
<p>Like most data controls, keep in mind that by default the <code>ListView</code> will call <code>toString()</code> to render the text for each item in your domain class. To render anything else, you will need to create your own custom cell formatting.</p>
<blockquote>
<p>To read about custom cell formatting and nodes for a <code>ListView</code>, read the section &quot;Custom Cell Formatting in ListView&quot; in Part 2 - Advanced Data Controls</p>
</blockquote>
<h3 id="tableview">TableView</h3>
<p>Probably one of the most significant builders in TornadoFX is the one for <code>TableView</code>. If you have worked with JavaFX, you might have experienced building a <code>TableView</code> in an object-oriented way. But TornadoFX provides a functional declaration construct pattern using extension functions that greatly simplify the coding of a <code>TableView</code>.</p>
<p>Say you have a domain type, such as <code>Person</code>.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> id</span>: <span class="hljs-keyword">Int</span>, <span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String, <span class="hljs-variable"><span class="hljs-keyword">val</span> birthday</span>: LocalDate) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> age</span>: <span class="hljs-keyword">Int</span> <span class="hljs-keyword">get</span>() = Period.between(birthday, LocalDate.now()).years
}
</code></pre>
<p>Take several instances of <code>Person</code> and put them in an <code>ObservableList</code>.</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> persons</span> = listOf(
        Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Samantha Stuart&quot;</span>,LocalDate.of(<span class="hljs-number">1981</span>,<span class="hljs-number">12</span>,<span class="hljs-number">4</span>)),
        Person(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Tom Marks&quot;</span>,LocalDate.of(<span class="hljs-number">2001</span>,<span class="hljs-number">1</span>,<span class="hljs-number">23</span>)),
        Person(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Stuart Gills&quot;</span>,LocalDate.of(<span class="hljs-number">1989</span>,<span class="hljs-number">5</span>,<span class="hljs-number">23</span>)),
        Person(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Nicole Williams&quot;</span>,LocalDate.of(<span class="hljs-number">1998</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>))
).observable()
</code></pre>
<p>You can quickly declare a <code>TableView</code> with all of its columns using a functional construct, and specify the <code>items</code> property to an <code>ObservableList&lt;Person&gt;</code> (Figure 5.3).</p>
<pre><code class="lang-kotlin">tableview(persons) {
    readonlyColumn(<span class="hljs-string">&quot;ID&quot;</span>,Person::id)
    readonlyColumn(<span class="hljs-string">&quot;Name&quot;</span>, Person::name)
    readonlyColumn(<span class="hljs-string">&quot;Birthday&quot;</span>, Person::birthday)
    readonlyColumn(<span class="hljs-string">&quot;Age&quot;</span>,Person::age)
}
</code></pre>
<p>Notice the use of the <code>readonlyColumn</code> builder instead of the <code>column</code> builder. The latter is used for mutable property references, but for data classes and immutable properties we need to use the <code>readonlyColumn</code> builder.</p>
<p><strong>Figure 5.3</strong></p>
<p><img src="https://camo.githubusercontent.com/21d91e000f36556b67bea322ff1152199aee483e/68747470733a2f2f692e696d6775722e636f6d2f41474d435038532e706e67" alt=""></p>
<p>The <code>column()</code> functions are extension functions for <code>TableView</code> accepting a <code>header</code> name and a mapped property using reflection syntax. TornadoFX will then take each mapping to render a value for each cell in that given column. A corresponding <code>readonlyColumn()</code> function is available to map immutable non-JavaFX properties.</p>
<blockquote>
<p>If you want granular control over <code>TableView</code> column resize policies, see Appendix A2 for more information on <code>SmartResize</code> policies.</p>
</blockquote>
<h4 id="using-property-properties">Using &quot;Property&quot; properties</h4>
<p>If you follow the JavaFX <code>Property</code> conventions to set up your domain class, it will automatically support value editing.</p>
<p>You can create these <code>Property</code> objects the conventional way, or you can use TornadoFX&apos;s <code>property</code> delegates to automatically create these <code>Property</code> declarations as shown below.</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">import</span> tornadofx.*

<span class="hljs-comment">// WARNING: This syntax is not recommended, keep reading :)</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(id: <span class="hljs-keyword">Int</span>, name: String, birthday: LocalDate) {
    <span class="hljs-variable"><span class="hljs-keyword">var</span> id by property(id)
    fun idProperty()</span> = getProperty(Person::id)

    <span class="hljs-variable"><span class="hljs-keyword">var</span> name by property(name)
    fun nameProperty()</span> = getProperty(Person::name)

    <span class="hljs-variable"><span class="hljs-keyword">var</span> birthday by property(birthday)
    fun birthdayProperty()</span> = getProperty(Person::birthday)

    <span class="hljs-variable"><span class="hljs-keyword">val</span> age</span>: <span class="hljs-keyword">Int</span> <span class="hljs-keyword">get</span>() = Period.between(birthday, LocalDate.now()).years
}
</code></pre>
<p>You need to create <code>xxxProperty()</code> functions for each property to support JavaFX&apos;s naming convention when it uses reflection. This can easily be done by relaying their calls to <code>getProperty()</code> to retrieve the <code>Property</code> for a given field. See the &quot;Property Delegates&quot; section in Part 2 for detailed information on how these property delegates work.</p>
<p>Now on the <code>TableView</code>, you can make it editable, map to the properties, and apply the appropriate cell-editing factories to make the values editable.</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = tableview(persons) {
    isEditable = <span class="hljs-literal">true</span>
    column(<span class="hljs-string">&quot;ID&quot;</span>,Person::idProperty).makeEditable()
    column(<span class="hljs-string">&quot;Name&quot;</span>, Person::nameProperty).makeEditable()
    column(<span class="hljs-string">&quot;Birthday&quot;</span>, Person::birthdayProperty).makeEditable()
    readonlyColumn(<span class="hljs-string">&quot;Age&quot;</span>,Person::age)
}
</code></pre>
<p>To allow editing and rendering, TornadoFX provides a few default cell factories you can invoke on a column easily through extension functions.</p>
<table>
<thead>
<tr>
<th>Extension Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>useTextField()</td>
<td>Uses a standard <code>TextField</code> to edit values with a provided <code>StringConverter</code></td>
</tr>
<tr>
<td>useComboBox()</td>
<td>Edits a cell value via a <code>ComboBox</code> with a specified <code>ObservableList&lt;T&gt;</code> of applicable values</td>
</tr>
<tr>
<td>useChoiceBox()</td>
<td>Accepts value changes to a cell with a <code>ChoiceBox</code></td>
</tr>
<tr>
<td>useCheckBox()</td>
<td>Renders an editable <code>CheckBox</code> for a <code>Boolean</code> value column</td>
</tr>
<tr>
<td>useProgressBar()</td>
<td>Renders the cell as a <code>ProgressBar</code> for a <code>Double</code> value column</td>
</tr>
</tbody>
</table>
<h5 id="property-syntax-alternatives">Property Syntax Alternatives</h5>
<p>If you do not care about exposing the <code>Property</code> in a function (which is common in practial usage) you can express your class like this:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(id: <span class="hljs-keyword">Int</span>, name: String, birthday: LocalDate) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> idProperty</span> = SimpleIntegerProperty(id)
    <span class="hljs-variable"><span class="hljs-keyword">var</span> id by idProperty

    <span class="hljs-keyword">val</span> nameProperty</span> = SimpleStringProperty(name)
    <span class="hljs-variable"><span class="hljs-keyword">var</span> name by nameProperty

    <span class="hljs-keyword">val</span> birthdayProperty</span> = SimpleObjectProperty(birthday)
    <span class="hljs-variable"><span class="hljs-keyword">var</span> birthday by birthdayProperty

    // Make age an observable value as well
    <span class="hljs-keyword">val</span> ageProperty</span> = birthdayProperty.objectBinding { Period.between(it, LocalDate.now()).years }
}
</code></pre>
<p>This alternative pattern exposes the <code>Property</code> as a field member instead of a function. If you like the above syntax but want to keep the function, you can make the property <code>private</code> and add the function like this:</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> nameProperty</span> = SimpleStringProperty(name)
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nameProperty</span><span class="hljs-params">()</span> = nameProperty</span>
<span class="hljs-variable"><span class="hljs-keyword">var</span> name by nameProperty
</span></code></pre>
<p>Choosing from these patterns are all a matter of taste, and you can use whatever version meets your needs or preferences best.</p>
<blockquote>
<p>You can also convert plain properties to JavaFX properties using the TornadoFX Plugin. Refer to Chapter 12 to learn how to do this.</p>
</blockquote>
<h4 id="using-cellformat">Using cellFormat()</h4>
<p>There are other extension functions applied to <code>TableView</code> that can assist the flow of declaring a <code>TableView</code>. For instance, you can call a <code>cellFormat()</code> function on a given column to apply formatting rules, such as highlighting &quot;Age&quot; values less than 18 (Figure 5.4).</p>
<pre><code class="lang-kotlin">tableview(persons) {
    column(<span class="hljs-string">&quot;ID&quot;</span>, Person::idProperty)
    column(<span class="hljs-string">&quot;Name&quot;</span>, Person::nameProperty)
    column(<span class="hljs-string">&quot;Birthday&quot;</span>, Person::birthdayProperty)
    column(<span class="hljs-string">&quot;Age&quot;</span>, Person::ageProperty).cellFormat {
        text = it.toString()
        style {
            <span class="hljs-keyword">if</span> (it <span class="hljs-type">&lt; 18) {
                backgroundColor += c(&quot;#8b0000&quot;)
                textFill = Color.WHITE
            } else {
                backgroundColor += Color.WHITE
                textFill = Color.BLACK
            }
        }
     }
}
</span></code></pre>
<p><strong>Figure 5.4</strong></p>
<p><img src="https://camo.githubusercontent.com/dbc9a172be484e4ab8eeb0accc3799500e9fe791/68747470733a2f2f692e696d6775722e636f6d2f4d7932475545762e706e67" alt=""></p>
<h4 id="accessing-nested-properties">Accessing Nested Properties</h4>
<p>Let&apos;s assume our <code>Person</code> object has a <code>parent</code> property which is also of type <code>Person</code>. To create a column for the parent name, we have several options. Our first attempt is simply extracting the name property manually:</p>
<pre><code class="lang-kotlin">column<span class="hljs-type">&lt;Person, String&gt;</span>(<span class="hljs-string">&quot;Parent name&quot;</span>, { it.value.parentProperty.value.nameProperty })
</code></pre>
<p>Notice how we cannot simply reference the property. We need to access the value provided in the callback to get to the actual instance and nest call to the <code>nameProperty</code>. While this works, it has one major drawback. If the parent changes, the <code>TableView</code> will not be updated. We can partially remedy this by defining the value for the property as the parent itself, and formatting its name:</p>
<pre><code class="lang-kotlin">column(<span class="hljs-string">&quot;Parent name&quot;</span>, Person::parentProperty).cellFormat {
    textProperty().bind(it.parentProperty.value.nameProperty)
}
</code></pre>
<p>It might still not update right away, even though it would eventually become consistent as the <code>TableView</code> refreshes.</p>
<p>To create a binding that would reflect a change to the parent property immediately, consider using a select binding, which we will cover later.</p>
<pre><code class="lang-kotlin">column<span class="hljs-type">&lt;Person, String&gt;</span>(<span class="hljs-string">&quot;Parent name&quot;</span>, { it.value.parentProperty.select(Person::nameProperty) })
</code></pre>
<h4 id="declaring-column-values-functionally">Declaring Column Values Functionally</h4>
<p>If you need to map a column&apos;s value to a non-property (such as a function), you can use a non-reflection means to extract the values for that column.</p>
<p>Say you have a <code>WeeklyReport</code> type that has a <code>getTotal()</code> function accepting a <code>DayOfWeek</code> argument (an enum of Monday, Tuesday... Sunday).</p>
<pre><code class="lang-kotlin">abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeeklyReport</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> startDate</span>: LocalDate) {
    abstract <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTotal</span><span class="hljs-params">(dayOfWeek: <span class="hljs-type">DayOfWeek</span>)</span>: BigDecimal</span>
}
</code></pre>
<p>Let&apos;s say you wanted to create a column for each <code>DayOfWeek</code>. You cannot map to properties, but you can map each <code>WeeklyReport</code> item explicitly to extract each value for that <code>DayOfWeek</code>.</p>
<pre><code class="lang-kotlin">tableview<span class="hljs-type">&lt;WeeklyReport&gt;</span> {
    <span class="hljs-keyword">for</span> (dayOfWeek <span class="hljs-keyword">in</span> DayOfWeek.values()) {
        column<span class="hljs-type">&lt;WeeklyReport, BigDecimal&gt;</span>(dayOfWeek.toString()) {
            ReadOnlyObjectWrapper(it.value.getTotal(dayOfWeek))
        }
    }
}
</code></pre>
<blockquote>
<p>This more closely resembles the traditional <code>setCellValueFactory()</code> for the JavaFX <code>TableColumn</code>.</p>
</blockquote>
<h4 id="row-expanders">Row Expanders</h4>
<p>Later we will learn about the <code>TreeTableView</code> which has a notion of &quot;parent&quot; and &quot;child&quot; rows, but the constraint with this control is the parent and child must have the same columns. Fortunately, TornadoFX comes with an awesome utility to not only reveal a &quot;child table&quot; for a given row, but any kind of <code>Node</code> control.</p>
<p>Say we have two domain types: <code>Region</code> and <code>Branch</code>. A <code>Region</code> is a geographical zone, and it contains one or more <code>Branch</code> items which are specific business operation locations (warehouses, distribution centers, etc). Here is a declaration of these types and some given instances.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Region</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> id</span>: <span class="hljs-keyword">Int</span>, <span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String, <span class="hljs-variable"><span class="hljs-keyword">val</span> country</span>: String, <span class="hljs-variable"><span class="hljs-keyword">val</span> branches</span>: ObservableList<span class="hljs-type">&lt;Branch&gt;</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Branch</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> id</span>: <span class="hljs-keyword">Int</span>, <span class="hljs-variable"><span class="hljs-keyword">val</span> facilityCode</span>: String, <span class="hljs-variable"><span class="hljs-keyword">val</span> city</span>: String, <span class="hljs-variable"><span class="hljs-keyword">val</span> stateProvince</span>: String)

<span class="hljs-variable"><span class="hljs-keyword">val</span> regions</span> = listOf(
        Region(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Pacific Northwest&quot;</span>, <span class="hljs-string">&quot;USA&quot;</span>,listOf(
                Branch(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;Seattle&quot;</span>,<span class="hljs-string">&quot;WA&quot;</span>),
                Branch(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;W&quot;</span>,<span class="hljs-string">&quot;Portland&quot;</span>,<span class="hljs-string">&quot;OR&quot;</span>)
        ).observable()),
        Region(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Alberta&quot;</span>, <span class="hljs-string">&quot;Canada&quot;</span>,listOf(
                Branch(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;W&quot;</span>,<span class="hljs-string">&quot;Calgary&quot;</span>,<span class="hljs-string">&quot;AB&quot;</span>)
        ).observable()),
        Region(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Midwest&quot;</span>, <span class="hljs-string">&quot;USA&quot;</span>, listOf(
                Branch(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;Chicago&quot;</span>,<span class="hljs-string">&quot;IL&quot;</span>),
                Branch(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;Frankfort&quot;</span>,<span class="hljs-string">&quot;KY&quot;</span>),
                Branch(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;W&quot;</span>,<span class="hljs-string">&quot;Indianapolis&quot;</span>, <span class="hljs-string">&quot;IN&quot;</span>)
        ).observable())
).observable()
</code></pre>
<p>We can create a <code>TableView</code> where each row has a <code>rowExpander()</code> function defined, and there we can arbitrarily create any <code>Node</code> control built off that particular row&apos;s item. In this case, we can nest another <code>TableView</code> for a given <code>Region</code> to show all the <code>Branch</code> items belonging to it. It will have a &quot;+&quot; button column to expand and show this expanded control (Figure 5.5).</p>
<p><strong>Figure 5.5</strong></p>
<p><img src="https://i.imgur.com/nXbjGpu.png" alt=""></p>
<p>There are a few configurability options, like &quot;expand on double-click&quot; behaviors and accessing the <code>expanderColumn</code> (the column with the &quot;+&quot; button) to drive a padding (Figure 5.6).</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = tableview(regions) {
        readonlyColumn(<span class="hljs-string">&quot;ID&quot;</span>,Region::id)
        readonlyColumn(<span class="hljs-string">&quot;Name&quot;</span>, Region::name)
        readonlyColumn(<span class="hljs-string">&quot;Country&quot;</span>, Region::country)
        rowExpander(expandOnDoubleClick = <span class="hljs-literal">true</span>) {
            paddingLeft = expanderColumn.width
            tableview(it.branches) {
                readonlyColumn(<span class="hljs-string">&quot;ID&quot;</span>,Branch::id)
                readonlyColumn(<span class="hljs-string">&quot;Facility Code&quot;</span>,Branch::facilityCode)
                readonlyColumn(<span class="hljs-string">&quot;City&quot;</span>,Branch::city)
                readonlyColumn(<span class="hljs-string">&quot;State/Province&quot;</span>,Branch::stateProvince)
            }
        }
    }
</code></pre>
<p><strong>Figure 5.6</strong></p>
<p><img src="https://i.imgur.com/DVco56O.png" alt=""></p>
<p>The <code>rowExpander()</code> function does not have to return a <code>TableView</code> but any kind of <code>Node</code>, including Forms and other simple or complex controls.</p>
<h4 id="accessing-the-expander-column">Accessing the Expander Column</h4>
<p>You might want to manipulate or call functions on the actual expander column. If you activate expand on double click, you might not want to show the expander column in the table at all. First we need a reference to the expander:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> expander</span> = rowExpander(<span class="hljs-literal">true</span>) { ... }
</code></pre>
<p>If you want to hide the expander column, just call <code>expander.isVisible = false</code>. You can also programmatically toggle the expanded state of any column by calling <code>expander.toggleExpanded(rowIndex)</code>.</p>
<h3 id="treeview">TreeView</h3>
<p>The <code>TreeView</code> contains elements where each element may contain child elements. Typically arrows allow you to expand a parent element to see its children. For instance, we can nest employees under department names</p>
<p>Traditionally in JavaFX, populating these elements is rather cumbersome and verbose. Fortunately TornadoFX makes it relatively simple.</p>
<p>Say you have a simple type <code>Person</code> and an <code>ObservableList</code> containing several instances.</p>
<pre><code class="lang-kotlin">data <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String, <span class="hljs-variable"><span class="hljs-keyword">val</span> department</span>: String)

<span class="hljs-variable"><span class="hljs-keyword">val</span> persons</span> = listOf(
        Person(<span class="hljs-string">&quot;Mary Hanes&quot;</span>,<span class="hljs-string">&quot;Marketing&quot;</span>),
        Person(<span class="hljs-string">&quot;Steve Folley&quot;</span>,<span class="hljs-string">&quot;Customer Service&quot;</span>),
        Person(<span class="hljs-string">&quot;John Ramsy&quot;</span>,<span class="hljs-string">&quot;IT Help Desk&quot;</span>),
        Person(<span class="hljs-string">&quot;Erlick Foyes&quot;</span>,<span class="hljs-string">&quot;Customer Service&quot;</span>),
        Person(<span class="hljs-string">&quot;Erin James&quot;</span>,<span class="hljs-string">&quot;Marketing&quot;</span>),
        Person(<span class="hljs-string">&quot;Jacob Mays&quot;</span>,<span class="hljs-string">&quot;IT Help Desk&quot;</span>),
        Person(<span class="hljs-string">&quot;Larry Cable&quot;</span>,<span class="hljs-string">&quot;Customer Service&quot;</span>)
        )
</code></pre>
<p>Creating a <code>TreeView</code> with the <code>treeview()</code> builder can be done functionally Figure 5.7).</p>
<pre><code class="lang-kotlin"><span class="hljs-comment">// Create Person objects for the departments</span>
<span class="hljs-comment">// with the department name as Person.name</span>

<span class="hljs-variable"><span class="hljs-keyword">val</span> departments</span> = persons
    .map { it.department }
    .distinct().map { Person(it, <span class="hljs-string">&quot;&quot;</span>) }

treeview<span class="hljs-type">&lt;Person&gt;</span> {
    <span class="hljs-comment">// Create root item</span>
    root = TreeItem(Person(<span class="hljs-string">&quot;Departments&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))

    <span class="hljs-comment">// Make sure the text in each TreeItem is the name of the Person</span>
    cellFormat { text = it.name }

    <span class="hljs-comment">// Generate items. Children of the root item will contain departments</span>
    populate { parent -&gt;
        <span class="hljs-keyword">if</span> (parent == root) departments <span class="hljs-keyword">else</span> persons.filter { it.department == parent.value.name }
    }
}
</code></pre>
<p><strong>Figure 5.7</strong></p>
<p><img src="https://i.imgur.com/jptTFqZ.png" alt=""></p>
<p>Let&apos;s break this down:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> departments</span> = persons
    .map { it.department }
    .distinct().map { Person(it, <span class="hljs-string">&quot;&quot;</span>) }
</code></pre>
<p>First we gather a distinct list of all the <code>departments</code> derived from the <code>persons</code> list. But then we put each <code>department</code> String in a <code>Person</code> object since the <code>TreeView</code> only accepts <code>Person</code> elements. While this is not very intuitive, this is the constraint and design of <code>TreeView</code>. We must make each <code>department</code> a <code>Person</code> for it to be accepted.</p>
<pre><code class="lang-kotlin">treeview<span class="hljs-type">&lt;Person&gt;</span> {
    <span class="hljs-comment">// Create root item</span>
    root = TreeItem(Person(<span class="hljs-string">&quot;Departments&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))
</code></pre>
<p>Next we specify the highest <code>root</code> for the <code>TreeView</code> that all departments will be nested under, and we give it a placeholder <code>Person</code> called &quot;Departments&quot;.</p>
<pre><code class="lang-kotlin">    cellFormat { text = it.name }
</code></pre>
<p>Then we specify the <code>cellFormat()</code> to render the <code>name</code> of each <code>Person</code> (including departments) on each cell.</p>
<pre><code class="lang-kotlin">   populate { parent -&gt;
        <span class="hljs-keyword">if</span> (parent == root) departments <span class="hljs-keyword">else</span> persons.filter { it.department == parent.value.name }
    }
</code></pre>
<p>Finally, we call the <code>populate()</code> function and provide a block instructing how to provide children to each <code>parent</code>. If the <code>parent</code> is indeed the <code>root</code>, then we return the <code>departments</code>. Otherwise the <code>parent</code> is a <code>department</code> and we provide a list of <code>Person</code> objects belonging to that <code>department</code>.</p>
<h3 id="data-driven-treeview">Data driven TreeView</h3>
<p>If the child list you return from <code>populate</code> is an <code>ObservableList</code>, any changes to that list will automatically be reflected in the TreeView. The populate function will be called for any new children that appears, and<br>removed items will result in removed TreeItems as well.</p>
<h4 id="treeview-with-differing-types">TreeView with Differing Types</h4>
<p>It is not necessarily intuitive to make every entity in the previous example a <code>Person</code>. We made each department a <code>Person</code> as well as the <code>root</code> &quot;Departments&quot;. For a more complex <code>TreeView&lt;T&gt;</code> where <code>T</code> is unknown and can be any number of types, it is better to specify type <code>T</code> as <code>Any</code>.</p>
<p>Using star projection, you can safely populate multiple types nested into the <code>TreeView</code>.</p>
<p>For instance, you can create a <code>Department</code> type and leverage <code>cellFormat()</code> to utilize type-checking for rendering. Then you can use a <code>populate()</code> function that will iterate over each element, and you specify the children for each element (if any).</p>
<pre><code class="lang-kotlin">data <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String)

<span class="hljs-comment">// Create Department objects for the departments by getting distinct values from Person.department</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> departments</span> = persons.map { it.department }.distinct().map { Department(it) }

<span class="hljs-comment">// Type safe way of extracting the correct TreeItem text</span>
cellFormat {
    text = <span class="hljs-keyword">when</span> (it) {
        <span class="hljs-keyword">is</span> String -&gt; it
        <span class="hljs-keyword">is</span> Department -&gt; it.name
        <span class="hljs-keyword">is</span> Person -&gt; it.name
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">&quot;Invalid value type&quot;</span>)
    }
}

<span class="hljs-comment">// Generate items. Children of the root item will contain departments, children of departments are filtered</span>
populate { parent -&gt;
    <span class="hljs-variable"><span class="hljs-keyword">val</span> value</span> = parent.value
    <span class="hljs-keyword">if</span> (parent == root) departments
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">is</span> Department) persons.filter { it.department == value.name }
    <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
}
</code></pre>
<h3 id="treetableview">TreeTableView</h3>
<p>The <code>TreeTableView</code> operates and functions similarly to a <code>TreeView</code>, but it has multiple columns since it is a table. Please note that the columns in a <code>TreeTableView</code> are the same for each parent and child element. If you want the columns to be different between parent and child, use a <code>TableView</code> with a <code>rowExpander()</code> as covered earlier in this chapter.</p>
<p>Say you have a <code>Person</code> class that optionally has an <code>employees</code> parameter, which defaults to an empty <code>List&lt;Person&gt;</code> if nobody reports to that <code>Person</code>.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> name</span>: String,
  <span class="hljs-variable"><span class="hljs-keyword">val</span> department</span>: String,
  <span class="hljs-variable"><span class="hljs-keyword">val</span> email</span>: String,
  <span class="hljs-variable"><span class="hljs-keyword">val</span> employees</span>: List<span class="hljs-type">&lt;Person&gt;</span> = emptyList())
</code></pre>
<p>Then you have an <code>ObservableList&lt;Person&gt;</code> holding instances of this class.</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> persons</span> = listOf(
        Person(<span class="hljs-string">&quot;Mary Hanes&quot;</span>, <span class="hljs-string">&quot;IT Administration&quot;</span>, <span class="hljs-string">&quot;mary.hanes@contoso.com&quot;</span>, listOf(
            Person(<span class="hljs-string">&quot;Jacob Mays&quot;</span>, <span class="hljs-string">&quot;IT Help Desk&quot;</span>, <span class="hljs-string">&quot;jacob.mays@contoso.com&quot;</span>),
            Person(<span class="hljs-string">&quot;John Ramsy&quot;</span>, <span class="hljs-string">&quot;IT Help Desk&quot;</span>, <span class="hljs-string">&quot;john.ramsy@contoso.com&quot;</span>))),
        Person(<span class="hljs-string">&quot;Erin James&quot;</span>, <span class="hljs-string">&quot;Human Resources&quot;</span>, <span class="hljs-string">&quot;erin.james@contoso.com&quot;</span>, listOf(
            Person(<span class="hljs-string">&quot;Erlick Foyes&quot;</span>, <span class="hljs-string">&quot;Customer Service&quot;</span>, <span class="hljs-string">&quot;erlick.foyes@contoso.com&quot;</span>),
            Person(<span class="hljs-string">&quot;Steve Folley&quot;</span>, <span class="hljs-string">&quot;Customer Service&quot;</span>, <span class="hljs-string">&quot;steve.folley@contoso.com&quot;</span>),
            Person(<span class="hljs-string">&quot;Larry Cable&quot;</span>, <span class="hljs-string">&quot;Customer Service&quot;</span>, <span class="hljs-string">&quot;larry.cable@contoso.com&quot;</span>)))
).observable()
</code></pre>
<p>You can create a <code>TreeTableView</code> by merging the components needed for a <code>TableView</code> and <code>TreeView</code> together. You will need to call the <code>populate()</code> function as well as set the root <code>TreeItem</code>.</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> treeTableView</span> = TreeTableView<span class="hljs-type">&lt;Person&gt;</span>().apply {
    column(<span class="hljs-string">&quot;Name&quot;</span>, Person::nameProperty)
    column(<span class="hljs-string">&quot;Department&quot;</span>, Person::departmentProperty)
    column(<span class="hljs-string">&quot;Email&quot;</span>, Person::emailProperty)

    <span class="hljs-comment">/// Create the root item that holds all top level employees</span>
    root = TreeItem(Person(<span class="hljs-string">&quot;Employees by leader&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, persons))

    <span class="hljs-comment">// Always return employees under the current person</span>
    populate { it.value.employees }

    <span class="hljs-comment">// Expand the two first levels</span>
    root.isExpanded = <span class="hljs-literal">true</span>
    root.children.forEach { it.isExpanded = <span class="hljs-literal">true</span> }

    <span class="hljs-comment">// Resize to display all elements on the first two levels</span>
    resizeColumnsToFitContent()
}
</code></pre>
<p>It is also possible to work with more of an ad hoc backing store like a <code>Map</code>. That would look something like this:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> tableData</span> = mapOf(
    <span class="hljs-string">&quot;Fruit&quot;</span> to arrayOf(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>),
    <span class="hljs-string">&quot;Veggies&quot;</span> to arrayOf(<span class="hljs-string">&quot;beans&quot;</span>, <span class="hljs-string">&quot;cauliflower&quot;</span>, <span class="hljs-string">&quot;cale&quot;</span>),
    <span class="hljs-string">&quot;Meat&quot;</span> to arrayOf(<span class="hljs-string">&quot;poultry&quot;</span>, <span class="hljs-string">&quot;pork&quot;</span>, <span class="hljs-string">&quot;beef&quot;</span>)
)

treetableview<span class="hljs-type">&lt;String&gt;</span>(TreeItem(<span class="hljs-string">&quot;Items&quot;</span>)) {
    column<span class="hljs-type">&lt;String, String&gt;</span>(<span class="hljs-string">&quot;Type&quot;</span>, { it.value.valueProperty() })
    populate {
        <span class="hljs-keyword">if</span> (it.value == <span class="hljs-string">&quot;Items&quot;</span>) tableData.keys
        <span class="hljs-keyword">else</span> tableData[it.value]?.asList()
    }
}
</code></pre>
<h3 id="datagrid">DataGrid</h3>
<p>A <code>DataGrid</code> is similar to the <code>GridPane</code> in that it displays items in a flexible grid of rows and columns, but the similarities ends there. While the <code>GridPane</code> requires you to add Nodes to the children list, the <code>DataGrid</code> is data driven in the same way as <code>TableView</code> and <code>ListView</code>. You supply it with a list of items and tell it how to convert those children to a graphical representation.</p>
<p>It supports selection of either a single item or multiple items at a time so it can be used as for example the display of an image viewer or other components where you want a visual representation of the underlying data. Usage wise it is close to a <code>ListView</code>, but you can create an arbitrary scene graph inside each cell so it is easy to visualize multiple properties for each item.</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> kittens</span> = listOf(<span class="hljs-string">&quot;https://i.imgur.com/DuFZ6PQb.jpg&quot;</span>, <span class="hljs-string">&quot;https://i.imgur.com/o2QoeNnb.jpg&quot;</span>) <span class="hljs-comment">// more items here</span>

datagrid(kittens) {
    cellCache {
         imageview(it)
    }
}
</code></pre>
<p><em>Figure 5.8</em></p>
<p><img src="https://i.imgur.com/9WGyVgZ.jpg" alt=""></p>
<p>The <code>cellCache</code> function receives each item in the list, and since we used a list of Strings in our example, we simply pass that string to the <code>imageview()</code> builder to create an <code>ImageView</code> inside each table cell. It is important to call the <code>cellCache</code> function instead of the <code>cellFormat</code> function to avoid recreating the images every time the <code>DataGrid</code> redraws. It will reuse the items.</p>
<p>Let&apos;s create a scene graph that is a little bit more involved, and also change the default size of each cell:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> numbers</span> = (<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).toList()

datagrid(numbers) {
    cellHeight = <span class="hljs-number">75.0</span>
    cellWidth = <span class="hljs-number">75.0</span>

    multiSelect = <span class="hljs-literal">true</span>

    cellCache {
        stackpane {
            circle(radius = <span class="hljs-number">25.0</span>) {
                fill = Color.FORESTGREEN
            }
            label(it.toString())
        }
    }
}
</code></pre>
<p><em>Figure 5.9</em></p>
<p><img src="https://i.imgur.com/UybXuTu.png" alt=""></p>
<p>The grid is supplied with a list of numbers this time. We start by specifying a cell height and width of 75 pixels, half of the default size. We also configure multi select to be able to select more than a single element. This is a shortcut of writing <code>selectionModel.selectionMode = SelectionMode.MULTIPLE</code> via an extension property. We create a <code>StackPane</code> that stacks a <code>Label</code> on top of a <code>Circle</code>.</p>
<blockquote>
<p>You might wonder why the label got so big and bold by default. This is coming from the <a href="https://github.com/edvin/tornadofx/blob/master/src/main/resources/tornadofx/datagrid.css" target="_blank">default stylesheet</a>. The stylesheet is a good starting point for further customization. All properties of the data grid can be configured in code as well as in CSS, and the stylesheet lists all possible style properties.</p>
<p>The number list showcased multiple selection. When a cell is selected, it receives the CSS pseudo class of <code>selected</code>. By default it will behave mostly like a <code>ListView</code> row with regards to selection styles. You can access the <code>selectionModel</code> of the data grid to listen for selection changes, see what items are selected etc.</p>
</blockquote>
<h3 id="summary">Summary</h3>
<p>Functional constructs work well with data controls like <code>TableView</code>, <code>TreeView</code>, and others we have seen in this chapter. Using the builder patterns, you can quickly and functionally declare how data is displayed.</p>
<p>In Chapter 7, we will embed controls in layouts to create more complex UI&apos;s easily.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="4. Basic Controls.html" class="navigation navigation-prev " aria-label="Previous page: 4. Basic Controls">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="6. CSS.html" class="navigation navigation-next " aria-label="Next page: 6. Type Safe CSS">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"5. Data Controls","level":"1.2.5","depth":2,"next":{"title":"6. Type Safe CSS","level":"1.2.6","depth":2,"path":"part1/6. CSS.md","ref":"part1/6. CSS.md","articles":[]},"previous":{"title":"4. Basic Controls","level":"1.2.4","depth":2,"path":"part1/4. Basic Controls.md","ref":"part1/4. Basic Controls.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"part1/5. Data Controls.md","mtime":"2020-02-13T15:46:37.950Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-02-13T15:47:39.413Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

