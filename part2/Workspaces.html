
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Workspaces · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Layout Debugger.html" />
    
    
    <link rel="prev" href="EventBus.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../part1/0. Subsection.html">
            
                <a href="../part1/0. Subsection.html">
            
                    
                    第一部分: TornadoFX 基本介紹
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../part1/1. Why TornadoFX.html">
            
                <a href="../part1/1. Why TornadoFX.html">
            
                    
                    1. 為什麼選擇 TornadoFX?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../part1/2. Setting Up.html">
            
                <a href="../part1/2. Setting Up.html">
            
                    
                    2. 配置
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../part1/3. Components.html">
            
                <a href="../part1/3. Components.html">
            
                    
                    3. 組件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../part1/4. Basic Controls.html">
            
                <a href="../part1/4. Basic Controls.html">
            
                    
                    4. Basic Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../part1/5. Data Controls.html">
            
                <a href="../part1/5. Data Controls.html">
            
                    
                    5. Data Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../part1/6. CSS.html">
            
                <a href="../part1/6. CSS.html">
            
                    
                    6. Type Safe CSS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../part1/7. Layouts and Menus.html">
            
                <a href="../part1/7. Layouts and Menus.html">
            
                    
                    7. Layouts and Menus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../part1/8. Charts.html">
            
                <a href="../part1/8. Charts.html">
            
                    
                    8. Charts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="../part1/9. Shapes and Animation.html">
            
                <a href="../part1/9. Shapes and Animation.html">
            
                    
                    9. Shapes and Animation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="../part1/10. FXML.html">
            
                <a href="../part1/10. FXML.html">
            
                    
                    10. FXML
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="../part1/11. Editing Models and Validation.html">
            
                <a href="../part1/11. Editing Models and Validation.html">
            
                    
                    11. Editing Models and Validation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="../part1/12. TornadoFX IDEA Plugin.html">
            
                <a href="../part1/12. TornadoFX IDEA Plugin.html">
            
                    
                    12. TornadoFX IDEA Plugin
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="0. Subsection.html">
            
                <a href="0. Subsection.html">
            
                    
                    Part 2: TornadoFX Advanced Features
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="Property Delegates.html">
            
                <a href="Property Delegates.html">
            
                    
                    Property Delegates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="Advanced Data Controls.html">
            
                <a href="Advanced Data Controls.html">
            
                    
                    Advanced Data Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="OSGi.html">
            
                <a href="OSGi.html">
            
                    
                    OSGi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="Scopes.html">
            
                <a href="Scopes.html">
            
                    
                    Scopes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="EventBus.html">
            
                <a href="EventBus.html">
            
                    
                    EventBus
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.6" data-path="Workspaces.html">
            
                <a href="Workspaces.html">
            
                    
                    Workspaces
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="Layout Debugger.html">
            
                <a href="Layout Debugger.html">
            
                    
                    Layout Debugger
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="Internationalization.html">
            
                <a href="Internationalization.html">
            
                    
                    Internationalization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="Config Settings and State.html">
            
                <a href="Config Settings and State.html">
            
                    
                    Config Settings and State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.10" data-path="JSON and REST.html">
            
                <a href="JSON and REST.html">
            
                    
                    JSON and REST
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.11" data-path="Dependency Injection.html">
            
                <a href="Dependency Injection.html">
            
                    
                    Dependency Injection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.12" data-path="Wizard.html">
            
                <a href="Wizard.html">
            
                    
                    Wizard
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.13" data-path="Integration.html">
            
                <a href="Integration.html">
            
                    
                    Integrating with other tech
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../part3/0. Subsection.html">
            
                <a href="../part3/0. Subsection.html">
            
                    
                    Part 3: Cook Book
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../part3/Snippets.html">
            
                <a href="../part3/Snippets.html">
            
                    
                    Snippets
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Workspaces</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="workspaces">Workspaces</h1>
<p>Java Business applications have traditionally been based on one of the Rich Client Frameworks,
namely the NetBeans Platform or Eclipse RCP. An important reason for choosing an RCP platform has been the workspace-like functionality they provide. Some important features of a workspace are:</p>
<ul>
<li>Common action buttons that tie to the state of the docked view (Save, Refresh, etc)</li>
<li>Context-based UI nodes added to the common workspace interface</li>
<li>Navigation stack for traversing visited views, controlled through back and forward buttons like a web browser</li>
<li>Menu system with dynamic contributions and modifications</li>
</ul>
<p>TornadoFX has begun to bridge the gap between the RCP platforms by providing Workspaces. While still in its infancy,
the default functionality is a solid foundation for business applications in need of the features discussed above.</p>
<h2 id="a-simple-workspace-example">A Simple Workspace Example</h2>
<p>To kick off a Workspace app, all you need to do is to subclass <code>App</code> and set the primary <code>View</code> to <code>Workspace::class</code>.
The result can be seen below (Figure 16.1):</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> : <span class="hljs-type">App</span></span>(Workspace::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
</code></pre>
<p><strong>Figure 16.1</strong></p>
<p><img src="https://i.imgur.com/7k3Uskm.png" alt=""></p>
<p>The resulting Workspace consists of a button bar with four default buttons and an empty content area below it.
The content area can house any <code>UIComponent</code>. You add a component to the <code>content</code> area by calling <code>workspace.dock()</code> on it. If you
show the <code>Workspace</code> without a docked <code>View</code>, it will by default only take up the space needed for the buttons. The window in Figure 16.1
was resized after it was opened.</p>
<p>Let&apos;s pretend we have a <code>CustomerList</code> component that we would like to dock in the <code>Workspace</code> as the application starts. We do this by overriding the <code>onBeforeShow</code> callback:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> : <span class="hljs-type">App</span></span>(Workspace::<span class="hljs-class"><span class="hljs-keyword">class</span>) </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBeforeShow</span><span class="hljs-params">(view: <span class="hljs-type">UIComponent</span>)</span> {</span>
        workspace.dock<span class="hljs-type">&lt;CustomerList&gt;</span>()
    }
}
</code></pre>
<p><strong>Figure 16.2</strong></p>
<p><img src="https://i.imgur.com/E79aeDl.png" alt=""></p>
<p>To keep things focused, we will leave out the <code>CustomerList</code> implementation code which simply displays a <code>TableView</code> with some Customers. What is interesting however, is that the <strong>Refresh</strong> button in the <code>Workspace</code> was enabled when the <code>CustomerList</code> was docked, while the <strong>Save</strong> button remained disabled.</p>
<h3 id="leveraging-the-workspace-buttons">Leveraging the Workspace buttons</h3>
<p>Whenever a <code>UIComponent</code> is docked in the <code>Workspace</code>, the <strong>Refresh</strong>, <strong>Save</strong>, and <strong>Delete</strong> buttons will be enabled by default. This happens because the <code>Workspace</code> looks at the <code>refreshable</code>, <code>savable</code> and <code>deletable</code> properties in the docked component. Every <code>UIComponent</code> returns a boolean property with the default value of <code>true</code>, which the <code>Workspace</code> then connects to the enabled state of these buttons. In the <code>CustomerList</code> example, the TornadoFX maintainers made sure the <strong>Save</strong> button was always disabled by overriding this property:</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> savable</span> = SimpleBooleanProperty(<span class="hljs-literal">false</span>)
</code></pre>
<p>We can achieve the same result by calling <code>disableSave()</code> in the <code>init</code> block, and the same goes for <code>disableRefresh()</code> and <code>disableDelete()</code>.</p>
<p>We did not touch the other buttons, so they remain <code>true</code> as per the default. Whenever the <code>Refresh</code> button is called, it will fire the <code>onRefresh</code> function in the <code>View</code>. You can override this to provide your refresh action:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span>: <span class="hljs-type">App</span></span>(MyWorkspace::<span class="hljs-class"><span class="hljs-keyword">class</span>) </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBeforeShow</span><span class="hljs-params">(view: <span class="hljs-type">UIComponent</span>)</span> {</span>
        workspace.dock<span class="hljs-type">&lt;MyView&gt;</span>()
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWorkspace</span>: <span class="hljs-type">Workspace</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> {</span>
      customerTable.asyncItems { customerController.listCustomers() }
    }
}
</code></pre>
<p>Same goes for the <strong>Delete</strong> button. We will revisit the <strong>Save</strong> button and introduce a neat trick to only activate it when there are dirty changes later in this chapter.</p>
<h3 id="tabbed-views">Tabbed Views</h3>
<p>You may at one point dock a View containing a <code>TabPane</code> inside of a <code>Workspace</code>, and then add tabs which represents further UIComponents. You can quite easily proxy the savable, refreshable and deletable state and actions from the <code>Workspace</code> onto the <code>View</code> represented by the currently active Tab. Consider a Customer Editor which has tabs for editing customer data, and one for editing contacts for that customer. Whenever the user selects one of the tabs, the buttons in the Workspace should interact with the state and actions from the selected tab view.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerEditor</span> : <span class="hljs-type">View</span></span>(<span class="hljs-string">&quot;Customer Editor&quot;</span>) {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = tabpane {
        tab(CustomerBasicDataEditor::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
        tab(ContactListEditor::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
        connectWorkspaceActions()
    }
}
</code></pre>
<p>That single call to <code>connectWorkspaceActions()</code> takes care of everything for us. The actual implementation of the two sub views are omitted for brevity, but you can imagine that they share a <code>CustomerViewModel</code> injected into the scope they share for example.</p>
<p>The actual implementation of <code>connectWorkspaceActions</code> is quite simple, and reveals what&apos;s going on under the cover:</p>
<pre><code class="lang-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> TabPane.<span class="hljs-title">connectWorkspaceActions</span><span class="hljs-params">()</span> {</span>
    savableWhen { savable }
    whenSaved { onSave() }

    deletableWhen { deletable }
    whenDeleted { onDelete() }

    refreshableWhen { refreshable }
    whenRefreshed { onRefresh() }
}
</code></pre>
<p>This function is declared inside <code>UIComponent</code>, so the <code>savableWhen</code>, <code>deletableWhen</code>, and <code>refreshableWhen</code> are performed on the UIComponent. Those state are then bound to the <code>savable</code>, <code>deletable</code> and <code>refreshable</code> state of the <code>TabPane</code>. But wait... a <code>TabPane</code> does not have those functions?! Yes, in TornadoFX it does :) You can probably guess that the implementation is again another proxy into the currently selected <code>Tab</code> in the <code>TabPane</code>, and a lookup of the UIComponent represented by the <code>content</code> property of that <code>Tab</code>. Whenever the <code>Tab</code> changes (or when the content of the tab changes), the underlying UIComponent is looked up, and the pertinent states are bound to the <code>Workspace</code>.</p>
<p>It would also be possible to bind these states and connect the actions more explicitly. You will never or seldom need to do that, but the following example might help your understanding of the proxy mechanism.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TooExplicitCustomerEditor</span> : <span class="hljs-type">View</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = tab {
        ...
    }
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> savable</span> = root.savable
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> refreshable</span> = root.refreshable
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> deletable</span> = root.deletable

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSave</span><span class="hljs-params">()</span> {</span>
        root.onSave()
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDelete</span><span class="hljs-params">()</span> {</span>
        root.onDelete()
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> {</span>
        root.onRefresh()
    }
}
</code></pre>
<p>As mentioned, you never need to do this and should always use the <code>connectWorkspaceActions</code> call, but you might want to override one of <code>onSave</code>, <code>onDelete</code>or <code>onRefresh</code> to perform some action in the main editor before calling the same action inside the active tab by calling <code>root.onXXX</code>. Let&apos;s say that the refresh call in the main editor reloads the customer, but you also want to have the contact list refresh if that view is currently active. This could be done
like this:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerEditor</span> : <span class="hljs-type">View</span></span>() {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> customerController</span> : CustomerController by inject()
    <span class="hljs-variable"><span class="hljs-keyword">val</span> customer</span>: CustomerModel by inject()

    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = tabpane {
        tab(CustomerBasicDataEditor::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
        tab(ContactListEditor::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
        connectWorkspaceActions()
    }

    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> onRefresh() {
        runAsync {
            customerController.getCustomer(customer.id.value)
        } ui {
            customer.item</span> = it
            root.onRefresh()
        }
    }
}
</code></pre>
<p>This little trick enables you to handle the actual reload of the customer in the main view instead of reimplementing it in every tab.</p>
<h3 id="forwarding-button-state-and-actions">Forwarding button state and actions</h3>
<p>As we have seen, the currently docked View controls the Workspace buttons. Some times you dock nested Views inside the main View, and you would like that nested View to control the buttons and actions instead. This can easily be done with the <code>forwardWorkspaceActions</code> function. You can change the forwarding however you see fit, for example on focus or on click on some component inside the nested View.</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerEditor</span> : <span class="hljs-type">View</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = hbox {
        <span class="hljs-variable"><span class="hljs-keyword">val</span> basicDataEditor</span> = find<span class="hljs-type">&lt;CustomerBasicDataEditor&gt;</span>()
        add(basicDataEditor)
        forwardWorkspaceActions(basicDataEditor)
        add(ContactListEditor::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
    }
}
</code></pre>
<h3 id="modifying-the-default-workspace">Modifying the default workspace</h3>
<p>The default workspace only gives you basic functionality. As your application grows you will want to suplement the
 toolbar with more buttons and controls, and maybe a <code>MenuBar</code> above it. For small modifications you can augment
 it in the <code>onBeforeFunction</code> as we did above, but you will most probably want to subclass as the customizations
 become more advanced. The following code and image is taken from a real world CRM application:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CRMWorkspace</span> : <span class="hljs-type">Workspace</span></span>() {
    init {
        add(MainMenu::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
        add(RestProgressBar::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
        add(SearchView::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
    }
}
</code></pre>
<p>The <code>CRMWorkspace</code> loads three other views into it. One providing a <code>MenuBar</code>, then the default <code>RestProgressBar</code> is
added, and lastly a <code>SearchView</code> providing a search input field is added.</p>
<p>The Workspace has a pretty good idea about where to place whatever you add to it. For example, buttons will by default
be added after the four default buttons, while other components are added to the far right of the ToolBar. The MenuBar
is automatically added above the ToolBar, at the top of the screen.</p>
<p>Figure 16.3 shows how it looks in production, with a little bit of custom styling and a <code>CustomerEditor</code> docked into it.
This application happens to be in Norwegian, and some of the information in the Customer card has been removed.</p>
<p><strong>Figure 16.3</strong></p>
<p><img src="https://i.imgur.com/BbqCYg9.png" alt=""></p>
<p>You will notice that the <strong>Save</strong> button is enabled in this View. This is because the <code>savable</code> property is bound to
the dirty state property of the view model:</p>
<pre><code class="lang-kotlin"><span class="hljs-variable"><span class="hljs-keyword">val</span> model</span>: CustomerModel by inject()
<span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> savable</span> = model.dirty
</code></pre>
<p>When a customer is loaded, the <strong>Save</strong> button will stay disabled until an edit has been made. To save, we override the <code>onSave</code> function:</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSave</span><span class="hljs-params">()</span> {</span>
    runAsync {
        customerController.save(customer.item)
    } ui { saved -&gt;
        customer.update(saved)
    }
}
</code></pre>
<p>This particular <code>customerController.save</code> call will return the <code>Customer</code> from the server once it is saved. If the server made any changes
to our customer object, they would have been reflected in the saved customer we got back. For that reason, we call
<code>customer.update(saved)</code> which is function you get for free if you implement <code>JsonModel</code>. This makes sure that changes
from the server is pushed back into the model. This is completely optional, and you might just want to do <code>customerController.save(customer.item)</code>.</p>
<h2 id="title-and-heading">Title and heading</h2>
<p>When a view is docked, the title of the Workspace will match the title of that view. There is also a heading
text in the workspace that by default shows the same text as the title. The heading can be overriden by assigning to
the <code>heading</code> variable or binding to the <code>headingProperty</code> property. If you want to completely remove the heading, augment
the workspace with <code>workspace.headingContainer.hide()</code> or just hide it. You can also put whatever
nodes you want inside the heading container. You saw this trick in the CRM screenshot, where a Gravator icon was placed
to the left of the customer name.</p>
<p>Important: Modifications to the workspace must be made from <code>onDock</code>. Trying to modify the Workspace from <code>init</code> will likely fail, as
the workspace is not guaranteed to be available while <code>init</code> is running. You can not change the enable/disable state of native
workspace buttons, as the workspace manages these internally based on the properties of the currently docked view.</p>
<h2 id="dynamic-elements-in-the-toolbar">Dynamic elements in the ToolBar</h2>
<p>Some views might need more buttons or functionality added to the ToolBar, but once you navigate away from the view it
wouldn&apos;t make sense to keep them around. The Workspace will actually track whatever elements you add to it while a view is
docked and remove those changes when the view is undocked. The perfect place to add these extra buttons would be the <code>onDock</code>
call of the view.</p>
<p>Every <code>UIComponent</code> has a property called <code>workspace</code> which will point to the current Workspace for the current Scope. Let&apos;s
add an &quot;Add Customer&quot; button to the Workspace whenever the <code>CustomerList</code> is docked:</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDock</span><span class="hljs-params">()</span> {</span>
    with (workspace) {
        button(<span class="hljs-string">&quot;Add Customer&quot;</span>).action {
            addCustomer()
        }
    }
}
</code></pre>
<p>The Workspace will now look like in Figure <strong>16.4</strong></p>
<p><img src="https://i.imgur.com/mSKv57I.png" alt=""></p>
<p>It looks like a default button. You can remove the border around the button by adding the <code>icon-only</code> css class to it. Optionally
you can configure an icon for the graphic node if you like. The built in icons are svg shapes added in the built in <code>workspace.css</code>
but feel free to add your icon in any way you see fit. Let&apos;s add an icon from the FontAwesomeFX library and make it look like
the other buttons:</p>
<pre><code class="lang-kotlin">button(<span class="hljs-string">&quot;Add Customer&quot;</span>) {
    addClass(<span class="hljs-string">&quot;icon-only&quot;</span>)
    graphic = FontAwesomeIconView(PLUS_CIRCLE).apply {
        style {
            fill = c(<span class="hljs-string">&quot;#818181&quot;</span>)
        }
        glyphSize = <span class="hljs-number">18</span>
    }
    action { addCustomer() }
}
</code></pre>
<p>In a real application you would use a css class so you don&apos;t need to configure the fill for every button you add. The result can be seen in Figure 16.5:</p>
<p><strong>Figure 16.5</strong></p>
<p><img src="https://i.imgur.com/32pmJAs.png" alt=""></p>
<h2 id="navigating-between-docked-views">Navigating between docked views</h2>
<p>Our Customer List is configured so that whenever you double click a customer you will be taken to an editor for that customer.
The TableView binds the selected user to a <code>CustomerModel</code> view model object, and the action is performed like this:</p>
<pre><code class="lang-kotlin">tableview(customers) {
    column(<span class="hljs-string">&quot;First Name&quot;</span>, Customer::firstNameProperty)
    column(<span class="hljs-string">&quot;Last Name&quot;</span>, Customer::lastNameProperty)
    bindSelected(model)
    onUserSelect { workspace.dock<span class="hljs-type">&lt;CustomerEditor&gt;</span>() }
}
</code></pre>
<p>The only thing we need to do is actually dock the <code>CustomerEditor</code> when the user selects a row. Since the <code>CustomerEditor</code>
will be looked up in the same scope we are currently in, it will have access to the selected customer as well:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerEditor</span> : <span class="hljs-type">Fragment</span></span>(<span class="hljs-string">&quot;Customer Editor&quot;</span>) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> customer</span>: CustomerModel by inject()
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> savable</span> = customer.dirty
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> headingProperty</span> = customer.fullName

    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = form {
        fieldset(<span class="hljs-string">&quot;Customer Details&quot;</span>) {
            field(<span class="hljs-string">&quot;First Name&quot;</span>) {
                textfield(customer.firstName)
            }
            field(<span class="hljs-string">&quot;Last Name&quot;</span>) {
                textfield(customer.lastName)
            }
        }
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSave</span><span class="hljs-params">()</span> {</span>
        customer.commit()
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> {</span>
        customer.rollback()
    }
}
</code></pre>
<p>The customer model is injected, and will contain the selected customer from the list. The <code>savable</code> property is bound
to the <code>dirty</code> property of the model and the <code>headingProperty</code> is bound to a <code>StringBinding</code> called <code>fullName</code>, which
concatinates the first and last names and updates whenever they are changed. The form fields bind to the name properties
and lastly the <code>onSave</code> and <code>onRefresh</code> functions are implemented to react to the corresponding Workspace buttons.</p>
<p><strong>Figure 16.6</strong></p>
<p><img src="https://i.imgur.com/ZPomPti.png" alt=""></p>
<p>We can see that the <code>title</code> and <code>heading</code> are indeed displaying separate information. Since we haven&apos;t made any edits
yet, the <strong>Save</strong> button is disabled, while the <strong>Refresh</strong> button is available, and would roll back any changes made
since the last commit.</p>
<p>The <code>back</code> button is enabled as well, and clicking it would navigate back to the Customer list. This is a very powerful
feature which enables browser like navigation in your application with very little effort on your part. The Workspace
keeps a navigation stack of configurable depth. By default it will contain 10 previously docked views. You can configure the
<code>maxViewStackDepth</code> to change the number of views held in the navigation stack.</p>
<h2 id="alternative-to-overriding-onsave-and-onrefresh">Alternative to overriding <code>onSave</code> and <code>onRefresh</code></h2>
<p>Some times you want to access an object in one of the workbench button actions but you want to avoid creating a variable
 for that object. Instead you can use the <code>whenSaved</code> and <code>whenRefreshed</code> callbacks, which can be configured from anywhere.
 Important: They are alternatives to <code>onSave</code> and <code>onRefresh</code> so you should only do one or the other. Let&apos;s say we want to
 refresh a TableView when the <strong>Refresh</strong> button is clicked. We can configure this inside the builder for the TableView:</p>
<pre><code class="lang-kotlin">tableview {
    whenRefreshed {
        asyncItems { controller.loadItems() }
    }
}
</code></pre>
<p>This is a handy alternative in some situations, but make sure you only choose one of the strategies.</p>
<h2 id="advanced-scope-navigation">Advanced scope navigation</h2>
<p>When you leverage injected view models together with a navigation stack, some interesting challenges appear that need
to be addressed. If you removed the <strong>Back</strong> button (<code>workspace.backButton.removeFromParent()</code>) or set the <code>maxViewStackDepth</code> to
<code>0</code> you can disregard this particular challenge, but to leverage this powerful navigation paradigm, there are some things
you need to think about.</p>
<p>Consider our prevous example with an injected <code>CustomerModel</code> that represents the currently selected customer in the <code>CustomerList</code>
while also being used by the <code>CustomerEditor</code> to edit that same customer. Then let&apos;s assume that there is a way to search for
a customer and edit it, perhaps using a <code>TextField</code> in the ToolBar of the Workspace as a search entry point. If you search for
a new customer and go on to edit it, then navigate back to the previous customer editor, it would suddenly operate on the
last customer you set in the <code>CustomerModel</code>. You can probably imagine the ensuing havoc.</p>
<p>Fortunately, the scoping support stretches far into the Workspace feature and provides some handy tools for this particular situation.</p>
<p>We need to find a way to contain the scope for the pair of CustomerList and CustomerEditor so they can work together while allowing
other views to use the <code>CustomerModel</code>, but in a different scope. It&apos;s actually quite easy. Whenever you create a new <code>CustomerList</code>,
also create a new Scope. If you were to do this manually, it would look something like this:</p>
<pre><code class="lang-kotlin"><span class="hljs-comment">// Create a new scope, but keep the current workspace</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> newScope</span> = Scope(workspace)

<span class="hljs-comment">// Find the CustomerList in the new scope</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> customerList</span> = find<span class="hljs-type">&lt;CustomerList&gt;</span>(newScope)

<span class="hljs-comment">// Dock the customerList in the workspace</span>
workspace.dock(customerList)
</code></pre>
<p>Those three distinct operations can be performed in a single call:</p>
<pre><code class="lang-kotlin">workspace.dockInNewScope<span class="hljs-type">&lt;CustomerList&gt;</span>()
</code></pre>
<p>When the CustomerList docks the CustomerEditor later on, it happens in this new scope. But what about the search field?</p>
<p>We would need to provide a separate scope for the <code>CustomerEditor</code> that should show the result of the search, but
were we would also also need to inject the customer model containing the selected customer into the new scope. This
following code is imagined inside the action that selects a customer from the search result:</p>
<pre><code class="lang-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">editCustomer</span><span class="hljs-params">(customer: <span class="hljs-type">Customer</span>)</span> {</span>
<span class="hljs-comment">// Create a view model for the customer</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> model</span> = CustomerModel(customer)

<span class="hljs-comment">// Create a new scope, but keep the current workspace</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> newScope</span> = Scope(workspace)

<span class="hljs-comment">// Insert the customer model into the new scope</span>
newScope.<span class="hljs-keyword">set</span>(model)

<span class="hljs-comment">// Find the CustomerEditor in the new scope</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> editor</span> = find<span class="hljs-type">&lt;CustomerEditor&gt;</span>(newScope)

<span class="hljs-comment">// Dock the editor</span>
workspace.dock(editor)
}
</code></pre>
<p>That&apos;s a lot of steps. Fortunately, we can do that as well in a single call:</p>
<pre><code class="lang-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">editCustomer</span><span class="hljs-params">(customer: <span class="hljs-type">Customer</span>)</span> {</span>
    workspace.dockInNewScope<span class="hljs-type">&lt;CustomerEditor&gt;</span>(CustomerModel(customer))
}
</code></pre>
<p>The <code>dockInNewScope</code> function takes a vararg list of injectable objects to insert into the new scope before looking
up our CustomerEditor and docking it.</p>
<p>Separating scopes this way makes sure we can utilize injected view models without being afraid of other views stepping
on our data. It is a pragmatic approach to an intricate problem. It also gives you a way of bleeding injectables
into new scopes, should your use case require it.</p>
<h2 id="custom-viewstack-optimizations">Custom ViewStack optimizations</h2>
<p>Some use cases might require you to make sure that the user cannot go back to a certain view after he has navigated
to the prior view. You can remove your self from the View Stack on unDock like this:</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onUndock</span><span class="hljs-params">()</span> {</span>
    workspace.viewStack.remove(this)
}
</code></pre>
<h2 id="docking-multiple-views-in-the-editor-area">Docking multiple views in the editor area</h2>
<p>The Workspace provides an alternative way to navigate between views. Instead of back and forward buttons, you can choose
to dock multiple views inside a TabPane in the editor area. The Workspace has a <code>navigationMode</code> property that lets
you change how the views are represented in the editor area. The default is <code>Workspace.NavigationMode.Stack</code>. The following example
creates a tabbed Workspace that automatically docks two views inside it when it&apos;s created:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TabbedWorkspace</span>: <span class="hljs-type">Workspace</span></span>(<span class="hljs-string">&quot;Tabbed Workspace&quot;</span>, NavigationMode.Tabs) {
    init {
        dock<span class="hljs-type">&lt;FirstView&gt;</span>()
        dock<span class="hljs-type">&lt;SecondView&gt;</span>()
    }
}
</code></pre>
<p><strong>Figure 16.7</strong></p>
<p><img src="https://i.imgur.com/jq6Ymsr.png" alt=""></p>
<blockquote>
<p>A Workspace in Tabs mode automatically hides the navigation buttons as they are no longer needed</p>
</blockquote>
<p>You can create a starting point for this Workspace from a normal <code>App</code> class:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TabbedWorkspaceApp</span> : <span class="hljs-type">App</span></span>(TabbedWorkspace::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
</code></pre>
<p>The views docked inside the Workspace tabs will have their <code>onDock</code> function called whenever they are added and
also when they are subsequently chosen as the active Tab. Correspondingly, the <code>onUndock</code> function is called
whenever it is no longer the active Tab, as well as when it&apos;s removed from the TabPane using the close button on the tab.</p>
<p>You can control the closable state of a View docked inside the TabPane via the <code>closeable</code> property in <code>UIComponent</code>.
It returns a <code>BooleanExpression</code> with the default value of <code>true</code> but you can override it to bind against another
property or simply return another <code>SimpleBooleanValue(false)</code> to make it uncloseable. This example makes sure you
cannot close the tab before the CustomerModel inside it is committed or rolled back:</p>
<pre><code class="lang-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerEditor</span> : <span class="hljs-type">View</span></span>(<span class="hljs-string">&quot;Customer Editor&quot;</span>) {
    <span class="hljs-variable"><span class="hljs-keyword">val</span> customer</span>: CustomerModel by inject()
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> closeable</span> = customer.dirty.not()
}
</code></pre>
<h2 id="drawer-navigation">Drawer navigation</h2>
<p>The Workspace has built in support for the Drawer control. You can access <code>workspace.leftDrawer</code> and <code>workspace.rightDrawer</code> to
add items to each drawer. They will show up on either the left or right side whenever you have added one or more items to them.</p>
<p>Items added from a View in <code>onDock</code> will automatically be removed when the View is undocked. Items added directly in the Workspace
subclass, from the <code>onBeforeShow</code> App callback or from any other place will stay until they are manually removed.</p>
<p>The combination of static and dynamic drawer items makes for a very powerful navigation and menu structure. Only your imagination is the limit!</p>
<p>The following example creates a customize Workspace primed with a docked Customer Editor in the editor area and the three
drawer items we created in the Drawer chapter configured statically in the <code>leftDrawer</code> of the Workspace:</p>
<pre><code class="lang-kotlin"><span class="hljs-comment">// A Form based View we will dock in the workspace editor area</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerEditor</span> : <span class="hljs-type">View</span></span>(<span class="hljs-string">&quot;Customer Editor&quot;</span>) {
    <span class="hljs-keyword">override</span> <span class="hljs-variable"><span class="hljs-keyword">val</span> root</span> = form {
        fieldset(title) {
            field(<span class="hljs-string">&quot;Name&quot;</span>) { textfield() }
            field(<span class="hljs-string">&quot;Username&quot;</span>) { textfield() }
            button(<span class="hljs-string">&quot;Save&quot;</span>)
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawerWorkspace</span> : <span class="hljs-type">Workspace</span></span>() {
    init {
        <span class="hljs-comment">// Dock the Customer Editor by default</span>
        dock<span class="hljs-type">&lt;CustomerEditor&gt;</span>()
    }

    init {
        <span class="hljs-comment">// Add items to the left drawers</span>
        with(leftDrawer) {
            item(<span class="hljs-string">&quot;Screencasts&quot;</span>) {
                webview {
                    prefWidth = <span class="hljs-number">470.0</span>
                    engine.userAgent = iPhoneUserAgent
                    engine.load(TornadoFXScreencastsURI)
                }
            }
            item(<span class="hljs-string">&quot;Links&quot;</span>) {
                listview(links) {
                    cellFormat { link -&gt;
                        graphic = hyperlink(link.name).action {
                            hostServices.showDocument(link.uri)
                        }
                    }
                }
            }
            item(<span class="hljs-string">&quot;People&quot;</span>) {
                tableview(people) {
                    column(<span class="hljs-string">&quot;Name&quot;</span>, Person::name)
                    column(<span class="hljs-string">&quot;Nick&quot;</span>, Person::nick)
                }
            }
        }
    }

    <span class="hljs-comment">// Sample data and configuration omitted for this example</span>
}
</code></pre>
<p>In Figure 16.8 we have expanded the <em>Links</em> drawer item. Notice how it pushes the Customer Editor to the right.</p>
<p><strong>Figure 16.8</strong></p>
<p><img src="https://i.imgur.com/HnQ2pFW.png" alt=""></p>
<p>By right clicking the drawer and checking the <code>Floating drawers</code> option, the expanded drawer item content will
instead float above the content, like in Figure 16.9:</p>
<p><strong>Figure 16.9</strong></p>
<p><img src="https://i.imgur.com/oiDvrMh.png" alt=""></p>
<p>This could be a good idea depending on the available space and the nature of the docked content. You can change the
floating drawer mode in code as well, by setting <code>leftDrawer.floatingDrawers = true</code>.</p>
<p>Remember that Views can contribute drawer items programmatically in their <code>onDock</code> callback. Use this to
provide extra tools for an advanced editor for example. They can easily communicate between each other
using ViewModels. It is recommended to create a new scope to make it easier for these view parts to work in concert
on shared data structures.</p>
<h2 id="vetoing-navigation-from-the-docked-view">Vetoing navigation from the docked View</h2>
<p>The currently docked View will receive a callback whenever the Back or Forward buttons of the Workspace is clicked. These functions
are called <code>onNavigateBack</code> and <code>onNavigateForward</code>. The default implementation returns true to signal that the navigation should proceed.
You can however return false to stop the navigation and instead implement your own logic to decide what happens in the UI when one of the
navigation buttons are clicked.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="EventBus.html" class="navigation navigation-prev " aria-label="Previous page: EventBus">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Layout Debugger.html" class="navigation navigation-next " aria-label="Next page: Layout Debugger">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Workspaces","level":"1.3.6","depth":2,"next":{"title":"Layout Debugger","level":"1.3.7","depth":2,"path":"part2/Layout Debugger.md","ref":"part2/Layout Debugger.md","articles":[]},"previous":{"title":"EventBus","level":"1.3.5","depth":2,"path":"part2/EventBus.md","ref":"part2/EventBus.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"part2/Workspaces.md","mtime":"2020-02-13T15:46:37.954Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-02-13T15:47:39.413Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

